/* tslint:disable */
/* eslint-disable */
/**
 * Coinbase Platform API
 * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.
 *
 * The version of the OpenAPI document: 0.0.1-alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * The ID of the wallet that owns the address
     * @type {string}
     * @memberof Address
     */
    'wallet_id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Address
     */
    'network_id': string;
    /**
     * The public key from which the address is derived.
     * @type {string}
     * @memberof Address
     */
    'public_key': string;
    /**
     * The onchain address derived on the server-side.
     * @type {string}
     * @memberof Address
     */
    'address_id': string;
    /**
     * The index of the address in the wallet.
     * @type {number}
     * @memberof Address
     */
    'index': number;
}
/**
 * 
 * @export
 * @interface AddressBalanceList
 */
export interface AddressBalanceList {
    /**
     * 
     * @type {Array<Balance>}
     * @memberof AddressBalanceList
     */
    'data': Array<Balance>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressBalanceList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressBalanceList
     */
    'next_page': string;
    /**
     * The total number of balances for the wallet.
     * @type {number}
     * @memberof AddressBalanceList
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface AddressHistoricalBalanceList
 */
export interface AddressHistoricalBalanceList {
    /**
     * 
     * @type {Array<HistoricalBalance>}
     * @memberof AddressHistoricalBalanceList
     */
    'data': Array<HistoricalBalance>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressHistoricalBalanceList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressHistoricalBalanceList
     */
    'next_page': string;
}
/**
 * 
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     * 
     * @type {Array<Address>}
     * @memberof AddressList
     */
    'data': Array<Address>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressList
     */
    'next_page': string;
    /**
     * The total number of addresses for the wallet.
     * @type {number}
     * @memberof AddressList
     */
    'total_count': number;
}
/**
 * The reputation score with metadata of a blockchain address.
 * @export
 * @interface AddressReputation
 */
export interface AddressReputation {
    /**
     * The score of a wallet address, ranging from -100 to 100. A negative score indicates a bad reputation, while a positive score indicates a good reputation.
     * @type {number}
     * @memberof AddressReputation
     */
    'score': number;
    /**
     * 
     * @type {AddressReputationMetadata}
     * @memberof AddressReputation
     */
    'metadata': AddressReputationMetadata;
}
/**
 * The metadata for the reputation score of onchain address.
 * @export
 * @interface AddressReputationMetadata
 */
export interface AddressReputationMetadata {
    /**
     * The total number of transactions performed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'total_transactions': number;
    /**
     * The number of unique days the address was active.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'unique_days_active': number;
    /**
     * The longest streak of consecutive active days.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'longest_active_streak': number;
    /**
     * The current streak of consecutive active days.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'current_active_streak': number;
    /**
     * The total number of days the address has been active.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'activity_period_days': number;
    /**
     * The number of token swaps performed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'token_swaps_performed': number;
    /**
     * The number of bridge transactions performed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'bridge_transactions_performed': number;
    /**
     * The number of lend, borrow, or stake transactions performed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'lend_borrow_stake_transactions': number;
    /**
     * The number of interactions with ENS contracts.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'ens_contract_interactions': number;
    /**
     * The number of smart contracts deployed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'smart_contract_deployments': number;
}
/**
 * 
 * @export
 * @interface AddressTransactionList
 */
export interface AddressTransactionList {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof AddressTransactionList
     */
    'data': Array<Transaction>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressTransactionList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressTransactionList
     */
    'next_page': string;
}
/**
 * An asset onchain scoped to a particular network, e.g. ETH on base-sepolia, or the USDC ERC20 Token on ethereum-mainnet.
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Asset
     */
    'network_id': string;
    /**
     * The ID for the asset on the network
     * @type {string}
     * @memberof Asset
     */
    'asset_id': string;
    /**
     * The number of decimals the asset supports. This is used to convert from atomic units to base units.
     * @type {number}
     * @memberof Asset
     */
    'decimals'?: number;
    /**
     * The optional contract address for the asset. This will be specified for smart contract-based assets, for example ERC20s.
     * @type {string}
     * @memberof Asset
     */
    'contract_address'?: string;
}
/**
 * The balance of an asset onchain
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof Balance
     */
    'amount': string;
    /**
     * 
     * @type {Asset}
     * @memberof Balance
     */
    'asset': Asset;
}
/**
 * 
 * @export
 * @interface BroadcastContractInvocationRequest
 */
export interface BroadcastContractInvocationRequest {
    /**
     * The hex-encoded signed payload of the contract invocation
     * @type {string}
     * @memberof BroadcastContractInvocationRequest
     */
    'signed_payload': string;
}
/**
 * 
 * @export
 * @interface BroadcastExternalTransferRequest
 */
export interface BroadcastExternalTransferRequest {
    /**
     * The hex-encoded signed payload of the external transfer
     * @type {string}
     * @memberof BroadcastExternalTransferRequest
     */
    'signed_payload': string;
}
/**
 * 
 * @export
 * @interface BroadcastStakingOperationRequest
 */
export interface BroadcastStakingOperationRequest {
    /**
     * The hex-encoded signed payload of the staking operation.
     * @type {string}
     * @memberof BroadcastStakingOperationRequest
     */
    'signed_payload': string;
    /**
     * The index in the transaction array of the staking operation.
     * @type {number}
     * @memberof BroadcastStakingOperationRequest
     */
    'transaction_index': number;
}
/**
 * 
 * @export
 * @interface BroadcastTradeRequest
 */
export interface BroadcastTradeRequest {
    /**
     * The hex-encoded signed payload of the trade
     * @type {string}
     * @memberof BroadcastTradeRequest
     */
    'signed_payload': string;
    /**
     * The hex-encoded signed payload of the approval transaction
     * @type {string}
     * @memberof BroadcastTradeRequest
     */
    'approve_transaction_signed_payload'?: string;
}
/**
 * 
 * @export
 * @interface BroadcastTransferRequest
 */
export interface BroadcastTransferRequest {
    /**
     * The hex-encoded signed payload of the transfer
     * @type {string}
     * @memberof BroadcastTransferRequest
     */
    'signed_payload': string;
}
/**
 * 
 * @export
 * @interface BuildStakingOperationRequest
 */
export interface BuildStakingOperationRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'asset_id': string;
    /**
     * The onchain address from which the staking transaction originates and is responsible for signing the transaction.
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'address_id': string;
    /**
     * The type of staking operation
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'action': string;
    /**
     * Additional options for the staking operation.
     * @type {{ [key: string]: string; }}
     * @memberof BuildStakingOperationRequest
     */
    'options': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CompileSmartContractRequest
 */
export interface CompileSmartContractRequest {
    /**
     * The JSON input containing the Solidity code, dependencies, and compiler settings.
     * @type {string}
     * @memberof CompileSmartContractRequest
     */
    'solidity_input_json': string;
    /**
     * The name of the contract to compile.
     * @type {string}
     * @memberof CompileSmartContractRequest
     */
    'contract_name': string;
    /**
     * The version of the Solidity compiler to use.
     * @type {string}
     * @memberof CompileSmartContractRequest
     */
    'solidity_compiler_version': string;
}
/**
 * Represents a compiled smart contract that can be deployed onchain
 * @export
 * @interface CompiledSmartContract
 */
export interface CompiledSmartContract {
    /**
     * The unique identifier of the compiled smart contract.
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'compiled_smart_contract_id'?: string;
    /**
     * The JSON-encoded input for the Solidity compiler
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'solidity_input_json'?: string;
    /**
     * The contract creation bytecode which will be used with constructor arguments to deploy the contract
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'contract_creation_bytecode'?: string;
    /**
     * The JSON-encoded ABI of the contract
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'abi'?: string;
    /**
     * The name of the smart contract to deploy
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'contract_name'?: string;
}
/**
 * Represents a single decoded event emitted by a smart contract
 * @export
 * @interface ContractEvent
 */
export interface ContractEvent {
    /**
     * The name of the blockchain network
     * @type {string}
     * @memberof ContractEvent
     */
    'network_id': string;
    /**
     * The name of the blockchain project or protocol
     * @type {string}
     * @memberof ContractEvent
     */
    'protocol_name': string;
    /**
     * The name of the specific contract within the project
     * @type {string}
     * @memberof ContractEvent
     */
    'contract_name': string;
    /**
     * The name of the event emitted by the contract
     * @type {string}
     * @memberof ContractEvent
     */
    'event_name': string;
    /**
     * The signature of the event, including parameter types
     * @type {string}
     * @memberof ContractEvent
     */
    'sig': string;
    /**
     * The first four bytes of the Keccak hash of the event signature
     * @type {string}
     * @memberof ContractEvent
     */
    'four_bytes': string;
    /**
     * The EVM address of the smart contract
     * @type {string}
     * @memberof ContractEvent
     */
    'contract_address': string;
    /**
     * The timestamp of the block in which the event was emitted
     * @type {string}
     * @memberof ContractEvent
     */
    'block_time': string;
    /**
     * The block number in which the event was emitted
     * @type {number}
     * @memberof ContractEvent
     */
    'block_height': number;
    /**
     * The transaction hash in which the event was emitted
     * @type {string}
     * @memberof ContractEvent
     */
    'tx_hash': string;
    /**
     * The index of the transaction within the block
     * @type {number}
     * @memberof ContractEvent
     */
    'tx_index': number;
    /**
     * The index of the event within the transaction
     * @type {number}
     * @memberof ContractEvent
     */
    'event_index': number;
    /**
     * The event data in a stringified format
     * @type {string}
     * @memberof ContractEvent
     */
    'data': string;
}
/**
 * A list of contract events with pagination information
 * @export
 * @interface ContractEventList
 */
export interface ContractEventList {
    /**
     * An array of ContractEvent objects
     * @type {Array<ContractEvent>}
     * @memberof ContractEventList
     */
    'data': Array<ContractEvent>;
    /**
     * The page token to be used to fetch the next page
     * @type {string}
     * @memberof ContractEventList
     */
    'next_page': string;
    /**
     * True if this list has another page of items after this one that can be fetched
     * @type {boolean}
     * @memberof ContractEventList
     */
    'has_more': boolean;
}
/**
 * A contract invocation onchain.
 * @export
 * @interface ContractInvocation
 */
export interface ContractInvocation {
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof ContractInvocation
     */
    'network_id': string;
    /**
     * The ID of the wallet that owns the address.
     * @type {string}
     * @memberof ContractInvocation
     */
    'wallet_id': string;
    /**
     * The onchain address of the address invoking the contract.
     * @type {string}
     * @memberof ContractInvocation
     */
    'address_id': string;
    /**
     * The ID of the contract invocation.
     * @type {string}
     * @memberof ContractInvocation
     */
    'contract_invocation_id': string;
    /**
     * The onchain address of the contract.
     * @type {string}
     * @memberof ContractInvocation
     */
    'contract_address': string;
    /**
     * The method to be invoked on the contract.
     * @type {string}
     * @memberof ContractInvocation
     */
    'method': string;
    /**
     * The JSON-encoded arguments to pass to the contract method. The keys should be the argument names and the values should be the argument values.
     * @type {string}
     * @memberof ContractInvocation
     */
    'args': string;
    /**
     * The JSON-encoded ABI of the contract.
     * @type {string}
     * @memberof ContractInvocation
     */
    'abi'?: string;
    /**
     * The amount to send to the contract for a payable method
     * @type {string}
     * @memberof ContractInvocation
     */
    'amount': string;
    /**
     * 
     * @type {Transaction}
     * @memberof ContractInvocation
     */
    'transaction': Transaction;
}
/**
 * 
 * @export
 * @interface ContractInvocationList
 */
export interface ContractInvocationList {
    /**
     * 
     * @type {Array<ContractInvocation>}
     * @memberof ContractInvocationList
     */
    'data': Array<ContractInvocation>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ContractInvocationList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ContractInvocationList
     */
    'next_page': string;
    /**
     * The total number of contract invocations for the address in the wallet.
     * @type {number}
     * @memberof ContractInvocationList
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface CreateAddressRequest
 */
export interface CreateAddressRequest {
    /**
     * The public key from which the address will be derived.
     * @type {string}
     * @memberof CreateAddressRequest
     */
    'public_key'?: string;
    /**
     * An attestation signed by the private key that is associated with the wallet. The attestation will be a hex-encoded signature of a json payload with fields `wallet_id` and `public_key`, signed by the private key associated with the public_key set in the request.
     * @type {string}
     * @memberof CreateAddressRequest
     */
    'attestation'?: string;
    /**
     * The index of the address within the wallet.
     * @type {number}
     * @memberof CreateAddressRequest
     */
    'address_index'?: number;
}
/**
 * 
 * @export
 * @interface CreateContractInvocationRequest
 */
export interface CreateContractInvocationRequest {
    /**
     * The address of the contract to invoke.
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'contract_address': string;
    /**
     * The method to invoke on the contract.
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'method': string;
    /**
     * The JSON-encoded arguments to pass to the contract method. The keys should be the argument names and the values should be the argument values.
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'args': string;
    /**
     * The JSON-encoded ABI of the contract.
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'abi'?: string;
    /**
     * The amount in atomic units of the native asset to send to the contract for a payable method
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface CreateExternalTransferRequest
 */
export interface CreateExternalTransferRequest {
    /**
     * The amount to transfer
     * @type {string}
     * @memberof CreateExternalTransferRequest
     */
    'amount': string;
    /**
     * The ID of the asset to transfer. Can be an asset symbol or a token contract address.
     * @type {string}
     * @memberof CreateExternalTransferRequest
     */
    'asset_id': string;
    /**
     * The destination address, which can be a 0x address, Basename, or ENS name
     * @type {string}
     * @memberof CreateExternalTransferRequest
     */
    'destination': string;
    /**
     * Whether the transfer uses sponsored gas
     * @type {boolean}
     * @memberof CreateExternalTransferRequest
     */
    'gasless': boolean;
    /**
     * When true, the transfer will be submitted immediately. Otherwise, the transfer will be batched. Defaults to false. Note: Requires the gasless option to be set to true. 
     * @type {boolean}
     * @memberof CreateExternalTransferRequest
     */
    'skip_batching'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateFundOperationRequest
 */
export interface CreateFundOperationRequest {
    /**
     * The amount of the asset to fund the address with in atomic units.
     * @type {string}
     * @memberof CreateFundOperationRequest
     */
    'amount': string;
    /**
     * The ID of the asset to fund the address with. Can be an asset symbol or a token contract address.
     * @type {string}
     * @memberof CreateFundOperationRequest
     */
    'asset_id': string;
    /**
     * The Optional ID of the fund quote to fund the address with. If omitted we will generate a quote and immediately execute it.
     * @type {string}
     * @memberof CreateFundOperationRequest
     */
    'fund_quote_id'?: string;
}
/**
 * 
 * @export
 * @interface CreateFundQuoteRequest
 */
export interface CreateFundQuoteRequest {
    /**
     * The amount of the asset to fund the address with in atomic units.
     * @type {string}
     * @memberof CreateFundQuoteRequest
     */
    'amount': string;
    /**
     * The ID of the asset to fund the address with. Can be an asset symbol alias or a token contract address.
     * @type {string}
     * @memberof CreateFundQuoteRequest
     */
    'asset_id': string;
}
/**
 * 
 * @export
 * @interface CreatePayloadSignatureRequest
 */
export interface CreatePayloadSignatureRequest {
    /**
     * The unsigned payload.
     * @type {string}
     * @memberof CreatePayloadSignatureRequest
     */
    'unsigned_payload': string;
    /**
     * The signature of the payload.
     * @type {string}
     * @memberof CreatePayloadSignatureRequest
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface CreateServerSignerRequest
 */
export interface CreateServerSignerRequest {
    /**
     * The ID of the server signer for the 1 of 1 server signer.
     * @type {string}
     * @memberof CreateServerSignerRequest
     */
    'server_signer_id'?: string;
    /**
     * The enrollment data of the server signer. This will be the base64 encoded server-signer-id for the 1 of 1 server signer.
     * @type {string}
     * @memberof CreateServerSignerRequest
     */
    'enrollment_data': string;
    /**
     * Whether the Server-Signer uses MPC.
     * @type {boolean}
     * @memberof CreateServerSignerRequest
     */
    'is_mpc': boolean;
}
/**
 * 
 * @export
 * @interface CreateSmartContractRequest
 */
export interface CreateSmartContractRequest {
    /**
     * 
     * @type {SmartContractType}
     * @memberof CreateSmartContractRequest
     */
    'type': SmartContractType;
    /**
     * 
     * @type {SmartContractOptions}
     * @memberof CreateSmartContractRequest
     */
    'options': SmartContractOptions;
    /**
     * The optional UUID of the compiled smart contract to deploy. This field is only required when SmartContractType is set to custom.
     * @type {string}
     * @memberof CreateSmartContractRequest
     */
    'compiled_smart_contract_id'?: string;
}


/**
 * 
 * @export
 * @interface CreateStakingOperationRequest
 */
export interface CreateStakingOperationRequest {
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'asset_id': string;
    /**
     * The type of staking operation.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'action': string;
    /**
     * Additional options for the staking operation.
     * @type {{ [key: string]: string; }}
     * @memberof CreateStakingOperationRequest
     */
    'options': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateTradeRequest
 */
export interface CreateTradeRequest {
    /**
     * The amount to trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'amount': string;
    /**
     * The ID of the asset to trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'from_asset_id': string;
    /**
     * The ID of the asset to receive from the trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'to_asset_id': string;
}
/**
 * 
 * @export
 * @interface CreateTransferRequest
 */
export interface CreateTransferRequest {
    /**
     * The amount to transfer
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'amount': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'network_id': string;
    /**
     * The ID of the asset to transfer. Can be an asset symbol or a token contract address.
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'asset_id': string;
    /**
     * The destination address, which can be a 0x address, Basename, or ENS name
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'destination': string;
    /**
     * Whether the transfer uses sponsored gas
     * @type {boolean}
     * @memberof CreateTransferRequest
     */
    'gasless'?: boolean;
    /**
     * When true, the transfer will be submitted immediately. Otherwise, the transfer will be batched. Defaults to false
     * @type {boolean}
     * @memberof CreateTransferRequest
     */
    'skip_batching'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateWalletRequest
 */
export interface CreateWalletRequest {
    /**
     * 
     * @type {CreateWalletRequestWallet}
     * @memberof CreateWalletRequest
     */
    'wallet': CreateWalletRequestWallet;
}
/**
 * Parameters for configuring a wallet
 * @export
 * @interface CreateWalletRequestWallet
 */
export interface CreateWalletRequestWallet {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateWalletRequestWallet
     */
    'network_id': string;
    /**
     * Whether the wallet should use the project\'s server signer or if the addresses in the wallets will belong to a private key the developer manages. Defaults to false.
     * @type {boolean}
     * @memberof CreateWalletRequestWallet
     */
    'use_server_signer'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateWalletWebhookRequest
 */
export interface CreateWalletWebhookRequest {
    /**
     * The URL to which the notifications will be sent.
     * @type {string}
     * @memberof CreateWalletWebhookRequest
     */
    'notification_uri': string;
    /**
     * The custom header to be used for x-webhook-signature header on callbacks, so developers can verify the requests are coming from Coinbase.
     * @type {string}
     * @memberof CreateWalletWebhookRequest
     */
    'signature_header'?: string;
}
/**
 * 
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'network_id': string;
    /**
     * 
     * @type {WebhookEventType}
     * @memberof CreateWebhookRequest
     */
    'event_type': WebhookEventType;
    /**
     * 
     * @type {WebhookEventTypeFilter}
     * @memberof CreateWebhookRequest
     */
    'event_type_filter'?: WebhookEventTypeFilter;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof CreateWebhookRequest
     */
    'event_filters'?: Array<WebhookEventFilter>;
    /**
     * The URL to which the notifications will be sent
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'notification_uri': string;
    /**
     * The custom header to be used for x-webhook-signature header on callbacks, so developers can verify the requests are coming from Coinbase.
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'signature_header'?: string;
}


/**
 * An amount in cryptocurrency
 * @export
 * @interface CryptoAmount
 */
export interface CryptoAmount {
    /**
     * The amount of the crypto in atomic units
     * @type {string}
     * @memberof CryptoAmount
     */
    'amount': string;
    /**
     * 
     * @type {Asset}
     * @memberof CryptoAmount
     */
    'asset': Asset;
}
/**
 * 
 * @export
 * @interface DeploySmartContractRequest
 */
export interface DeploySmartContractRequest {
    /**
     * The hex-encoded signed payload of the contract deployment transaction.
     * @type {string}
     * @memberof DeploySmartContractRequest
     */
    'signed_payload': string;
}
/**
 * Represents an event triggered by an ERC-20 token transfer on the blockchain. Contains information about the transaction, block, and involved addresses.
 * @export
 * @interface ERC20TransferEvent
 */
export interface ERC20TransferEvent {
    /**
     * Unique identifier for the webhook that triggered this event.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'webhookId'?: string;
    /**
     * Type of event, in this case, an ERC-20 token transfer.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'eventType'?: string;
    /**
     * Blockchain network where the event occurred.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'network'?: string;
    /**
     * Hash of the block containing the transaction.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'blockHash'?: string;
    /**
     * Number of the block containing the transaction.
     * @type {number}
     * @memberof ERC20TransferEvent
     */
    'blockNumber'?: number;
    /**
     * Timestamp when the block was mined.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'blockTime'?: string;
    /**
     * Hash of the transaction that triggered the event.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'transactionHash'?: string;
    /**
     * Position of the transaction within the block.
     * @type {number}
     * @memberof ERC20TransferEvent
     */
    'transactionIndex'?: number;
    /**
     * Position of the event log within the transaction.
     * @type {number}
     * @memberof ERC20TransferEvent
     */
    'logIndex'?: number;
    /**
     * Address of the ERC-20 token contract.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'contractAddress'?: string;
    /**
     * Address of the sender in the token transfer.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'from'?: string;
    /**
     * Address of the recipient in the token transfer.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'to'?: string;
    /**
     * Amount of tokens transferred, typically in the smallest unit (e.g., wei for Ethereum).
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'value'?: string;
}
/**
 * Represents an event triggered by an ERC-721 token transfer on the blockchain. Contains information about the transaction, block, and involved addresses.
 * @export
 * @interface ERC721TransferEvent
 */
export interface ERC721TransferEvent {
    /**
     * Unique identifier for the webhook that triggered this event.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'webhookId'?: string;
    /**
     * Type of event, in this case, an ERC-721 token transfer.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'eventType'?: string;
    /**
     * Blockchain network where the event occurred.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'network'?: string;
    /**
     * Hash of the block containing the transaction.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'blockHash'?: string;
    /**
     * Number of the block containing the transaction.
     * @type {number}
     * @memberof ERC721TransferEvent
     */
    'blockNumber'?: number;
    /**
     * Timestamp when the block was mined.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'blockTime'?: string;
    /**
     * Hash of the transaction that triggered the event.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'transactionHash'?: string;
    /**
     * Position of the transaction within the block.
     * @type {number}
     * @memberof ERC721TransferEvent
     */
    'transactionIndex'?: number;
    /**
     * Position of the event log within the transaction.
     * @type {number}
     * @memberof ERC721TransferEvent
     */
    'logIndex'?: number;
    /**
     * Address of the ERC-721 token contract.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'contractAddress'?: string;
    /**
     * Address of the sender in the token transfer.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'from'?: string;
    /**
     * Address of the recipient in the token transfer.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'to'?: string;
    /**
     * Unique identifier of the NFT being transferred.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'tokenId'?: string;
}
/**
 * 
 * @export
 * @interface EthereumTokenTransfer
 */
export interface EthereumTokenTransfer {
    /**
     * 
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'contract_address': string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'from_address': string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'to_address': string;
    /**
     * The value of the transaction in atomic units of the token being transfer for ERC20 or ERC1155 contracts.
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'value'?: string;
    /**
     * The ID of ERC721 or ERC1155 token being transferred.
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'token_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EthereumTokenTransfer
     */
    'log_index': number;
    /**
     * 
     * @type {TokenTransferType}
     * @memberof EthereumTokenTransfer
     */
    'token_transfer_type': TokenTransferType;
}


/**
 * 
 * @export
 * @interface EthereumTransaction
 */
export interface EthereumTransaction {
    /**
     * The onchain address of the sender.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'from': string;
    /**
     * The amount of gas spent in the transaction.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'gas'?: number;
    /**
     * The price per gas spent in the transaction in atomic units of the native asset.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'gas_price'?: number;
    /**
     * The hash of the transaction as a hexadecimal string, prefixed with 0x.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'hash'?: string;
    /**
     * The input data of the transaction.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'input'?: string;
    /**
     * The nonce of the transaction in the source address.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'nonce'?: number;
    /**
     * The onchain address of the receiver.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'to': string;
    /**
     * The index of the transaction in the block.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'index'?: number;
    /**
     * The value of the transaction in atomic units of the native asset.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'value'?: string;
    /**
     * The EIP-2718 transaction type. See https://eips.ethereum.org/EIPS/eip-2718 for more details.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'type'?: number;
    /**
     * The max fee per gas as defined in EIP-1559. https://eips.ethereum.org/EIPS/eip-1559 for more details.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'max_fee_per_gas'?: number;
    /**
     * The max priority fee per gas as defined in EIP-1559. https://eips.ethereum.org/EIPS/eip-1559 for more details.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'max_priority_fee_per_gas'?: number;
    /**
     * The confirmed priority fee per gas as defined in EIP-1559. https://eips.ethereum.org/EIPS/eip-1559 for more details.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'priority_fee_per_gas'?: number;
    /**
     * 
     * @type {EthereumTransactionAccessList}
     * @memberof EthereumTransaction
     */
    'transaction_access_list'?: EthereumTransactionAccessList;
    /**
     * 
     * @type {Array<EthereumTokenTransfer>}
     * @memberof EthereumTransaction
     */
    'token_transfers'?: Array<EthereumTokenTransfer>;
    /**
     * 
     * @type {Array<EthereumTransactionFlattenedTrace>}
     * @memberof EthereumTransaction
     */
    'flattened_traces'?: Array<EthereumTransactionFlattenedTrace>;
    /**
     * The timestamp of the block in which the event was emitted
     * @type {string}
     * @memberof EthereumTransaction
     */
    'block_timestamp'?: string;
    /**
     * This is for handling optimism rollup specific EIP-2718 transaction type field.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'mint'?: string;
    /**
     * RLP encoded transaction as a hex string (prefixed with 0x) for native compatibility with popular eth clients such as etherjs, viem etc.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'rlp_encoded_tx'?: string;
}
/**
 * 
 * @export
 * @interface EthereumTransactionAccess
 */
export interface EthereumTransactionAccess {
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionAccess
     */
    'address'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EthereumTransactionAccess
     */
    'storage_keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EthereumTransactionAccessList
 */
export interface EthereumTransactionAccessList {
    /**
     * 
     * @type {Array<EthereumTransactionAccess>}
     * @memberof EthereumTransactionAccessList
     */
    'access_list'?: Array<EthereumTransactionAccess>;
}
/**
 * 
 * @export
 * @interface EthereumTransactionFlattenedTrace
 */
export interface EthereumTransactionFlattenedTrace {
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'to'?: string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'value'?: string;
    /**
     * 
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'gas'?: number;
    /**
     * 
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'gas_used'?: number;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'input'?: string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'output'?: string;
    /**
     * 
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'sub_traces'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'trace_address'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'trace_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'call_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'trace_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'block_hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'block_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'transaction_hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'transaction_index'?: number;
}
/**
 * An Ethereum validator.
 * @export
 * @interface EthereumValidatorMetadata
 */
export interface EthereumValidatorMetadata {
    /**
     * The index of the validator in the validator set.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'index': string;
    /**
     * The public key of the validator.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'public_key': string;
    /**
     * The address to which the validator\'s rewards are sent.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'withdrawal_address': string;
    /**
     * Whether the validator has been slashed.
     * @type {boolean}
     * @memberof EthereumValidatorMetadata
     */
    'slashed': boolean;
    /**
     * The epoch at which the validator was activated.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'activationEpoch': string;
    /**
     * The epoch at which the validator exited.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'exitEpoch': string;
    /**
     * The epoch at which the validator can withdraw.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'withdrawableEpoch': string;
    /**
     * 
     * @type {Balance}
     * @memberof EthereumValidatorMetadata
     */
    'balance': Balance;
    /**
     * 
     * @type {Balance}
     * @memberof EthereumValidatorMetadata
     */
    'effective_balance': Balance;
}
/**
 * The faucet transaction
 * @export
 * @interface FaucetTransaction
 */
export interface FaucetTransaction {
    /**
     * The transaction hash of the transaction the faucet created.
     * @type {string}
     * @memberof FaucetTransaction
     */
    'transaction_hash': string;
    /**
     * Link to the transaction on the blockchain explorer.
     * @type {string}
     * @memberof FaucetTransaction
     */
    'transaction_link': string;
    /**
     * 
     * @type {Transaction}
     * @memberof FaucetTransaction
     */
    'transaction': Transaction;
}
/**
 * 
 * @export
 * @interface FeatureSet
 */
export interface FeatureSet {
    /**
     * Whether the network supports a faucet
     * @type {boolean}
     * @memberof FeatureSet
     */
    'faucet': boolean;
    /**
     * Whether the network supports Server-Signers
     * @type {boolean}
     * @memberof FeatureSet
     */
    'server_signer': boolean;
    /**
     * Whether the network supports transfers
     * @type {boolean}
     * @memberof FeatureSet
     */
    'transfer': boolean;
    /**
     * Whether the network supports trading
     * @type {boolean}
     * @memberof FeatureSet
     */
    'trade': boolean;
    /**
     * Whether the network supports staking
     * @type {boolean}
     * @memberof FeatureSet
     */
    'stake': boolean;
    /**
     * Whether the network supports gasless sends
     * @type {boolean}
     * @memberof FeatureSet
     */
    'gasless_send': boolean;
}
/**
 * 
 * @export
 * @interface FetchHistoricalStakingBalances200Response
 */
export interface FetchHistoricalStakingBalances200Response {
    /**
     * 
     * @type {Array<StakingBalance>}
     * @memberof FetchHistoricalStakingBalances200Response
     */
    'data': Array<StakingBalance>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof FetchHistoricalStakingBalances200Response
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof FetchHistoricalStakingBalances200Response
     */
    'next_page': string;
}
/**
 * 
 * @export
 * @interface FetchStakingRewards200Response
 */
export interface FetchStakingRewards200Response {
    /**
     * 
     * @type {Array<StakingReward>}
     * @memberof FetchStakingRewards200Response
     */
    'data': Array<StakingReward>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof FetchStakingRewards200Response
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof FetchStakingRewards200Response
     */
    'next_page': string;
}
/**
 * 
 * @export
 * @interface FetchStakingRewardsRequest
 */
export interface FetchStakingRewardsRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'network_id': string;
    /**
     * The ID of the asset for which the staking rewards are being fetched
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'asset_id': string;
    /**
     * The onchain addresses for which the staking rewards are being fetched
     * @type {Array<string>}
     * @memberof FetchStakingRewardsRequest
     */
    'address_ids': Array<string>;
    /**
     * The start time of this reward period
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'start_time': string;
    /**
     * The end time of this reward period
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'end_time': string;
    /**
     * 
     * @type {StakingRewardFormat}
     * @memberof FetchStakingRewardsRequest
     */
    'format': StakingRewardFormat;
}


/**
 * An amount in fiat currency
 * @export
 * @interface FiatAmount
 */
export interface FiatAmount {
    /**
     * The amount of the fiat in whole units.
     * @type {string}
     * @memberof FiatAmount
     */
    'amount': string;
    /**
     * The currency of the fiat
     * @type {string}
     * @memberof FiatAmount
     */
    'currency': string;
}
/**
 * An operation to fund a wallet with crypto
 * @export
 * @interface FundOperation
 */
export interface FundOperation {
    /**
     * The ID of the fund operation
     * @type {string}
     * @memberof FundOperation
     */
    'fund_operation_id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof FundOperation
     */
    'network_id': string;
    /**
     * The ID of the wallet that will receive the crypto
     * @type {string}
     * @memberof FundOperation
     */
    'wallet_id': string;
    /**
     * The ID of the address that will receive the crypto
     * @type {string}
     * @memberof FundOperation
     */
    'address_id': string;
    /**
     * 
     * @type {CryptoAmount}
     * @memberof FundOperation
     */
    'crypto_amount': CryptoAmount;
    /**
     * 
     * @type {FiatAmount}
     * @memberof FundOperation
     */
    'fiat_amount': FiatAmount;
    /**
     * 
     * @type {FundOperationFees}
     * @memberof FundOperation
     */
    'fees': FundOperationFees;
    /**
     * The status of the fund operation
     * @type {string}
     * @memberof FundOperation
     */
    'status': FundOperationStatusEnum;
}

export const FundOperationStatusEnum = {
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type FundOperationStatusEnum = typeof FundOperationStatusEnum[keyof typeof FundOperationStatusEnum];

/**
 * The fees for a fund operation.
 * @export
 * @interface FundOperationFees
 */
export interface FundOperationFees {
    /**
     * 
     * @type {FiatAmount}
     * @memberof FundOperationFees
     */
    'buy_fee': FiatAmount;
    /**
     * 
     * @type {CryptoAmount}
     * @memberof FundOperationFees
     */
    'transfer_fee': CryptoAmount;
}
/**
 * Paginated list of fund operations
 * @export
 * @interface FundOperationList
 */
export interface FundOperationList {
    /**
     * 
     * @type {Array<FundOperation>}
     * @memberof FundOperationList
     */
    'data': Array<FundOperation>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof FundOperationList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof FundOperationList
     */
    'next_page': string;
    /**
     * The total number of fund operations
     * @type {number}
     * @memberof FundOperationList
     */
    'total_count': number;
}
/**
 * A quote for a fund operation
 * @export
 * @interface FundQuote
 */
export interface FundQuote {
    /**
     * The ID of the fund quote
     * @type {string}
     * @memberof FundQuote
     */
    'fund_quote_id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof FundQuote
     */
    'network_id': string;
    /**
     * The ID of the wallet that will receive the crypto
     * @type {string}
     * @memberof FundQuote
     */
    'wallet_id': string;
    /**
     * The ID of the address that will receive the crypto
     * @type {string}
     * @memberof FundQuote
     */
    'address_id': string;
    /**
     * 
     * @type {CryptoAmount}
     * @memberof FundQuote
     */
    'crypto_amount': CryptoAmount;
    /**
     * 
     * @type {FiatAmount}
     * @memberof FundQuote
     */
    'fiat_amount': FiatAmount;
    /**
     * The time at which the quote expires
     * @type {string}
     * @memberof FundQuote
     */
    'expires_at': string;
    /**
     * 
     * @type {FundOperationFees}
     * @memberof FundQuote
     */
    'fees': FundOperationFees;
}
/**
 * 
 * @export
 * @interface GetStakingContextRequest
 */
export interface GetStakingContextRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'asset_id': string;
    /**
     * The onchain address for which the staking context is being fetched
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'address_id': string;
    /**
     * Additional options for getting the staking context. This typically includes network specific fields.
     * @type {{ [key: string]: string; }}
     * @memberof GetStakingContextRequest
     */
    'options': { [key: string]: string; };
}
/**
 * The balance of an asset onchain at a particular block
 * @export
 * @interface HistoricalBalance
 */
export interface HistoricalBalance {
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof HistoricalBalance
     */
    'amount': string;
    /**
     * The hash of the block at which the balance was recorded
     * @type {string}
     * @memberof HistoricalBalance
     */
    'block_hash': string;
    /**
     * The block height at which the balance was recorded
     * @type {string}
     * @memberof HistoricalBalance
     */
    'block_height': string;
    /**
     * 
     * @type {Asset}
     * @memberof HistoricalBalance
     */
    'asset': Asset;
}
/**
 * An error response from the Coinbase Developer Platform API
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A short string representing the reported error. Can be use to handle errors programmatically.
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * A human-readable message providing more details about the error.
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * A unique identifier for the request that generated the error. This can be used to help debug issues with the API.
     * @type {string}
     * @memberof ModelError
     */
    'correlation_id'?: string;
}
/**
 * Options for multi-token contract creation
 * @export
 * @interface MultiTokenContractOptions
 */
export interface MultiTokenContractOptions {
    /**
     * The URI for all token metadata
     * @type {string}
     * @memberof MultiTokenContractOptions
     */
    'uri': string;
}
/**
 * Options for NFT contract creation
 * @export
 * @interface NFTContractOptions
 */
export interface NFTContractOptions {
    /**
     * The name of the NFT
     * @type {string}
     * @memberof NFTContractOptions
     */
    'name': string;
    /**
     * The symbol of the NFT
     * @type {string}
     * @memberof NFTContractOptions
     */
    'symbol': string;
    /**
     * The base URI for the NFT metadata
     * @type {string}
     * @memberof NFTContractOptions
     */
    'base_uri': string;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof Network
     */
    'id': NetworkIdentifier;
    /**
     * The human-readable name of the blockchain network
     * @type {string}
     * @memberof Network
     */
    'display_name': string;
    /**
     * The chain ID of the blockchain network
     * @type {number}
     * @memberof Network
     */
    'chain_id': number;
    /**
     * The protocol family of the blockchain network
     * @type {string}
     * @memberof Network
     */
    'protocol_family': NetworkProtocolFamilyEnum;
    /**
     * Whether the network is a testnet or not
     * @type {boolean}
     * @memberof Network
     */
    'is_testnet': boolean;
    /**
     * 
     * @type {Asset}
     * @memberof Network
     */
    'native_asset': Asset;
    /**
     * 
     * @type {FeatureSet}
     * @memberof Network
     */
    'feature_set': FeatureSet;
    /**
     * The BIP44 path prefix for the network
     * @type {string}
     * @memberof Network
     */
    'address_path_prefix'?: string;
}

export const NetworkProtocolFamilyEnum = {
    Evm: 'evm',
    Solana: 'solana'
} as const;

export type NetworkProtocolFamilyEnum = typeof NetworkProtocolFamilyEnum[keyof typeof NetworkProtocolFamilyEnum];

/**
 * The ID of the blockchain network. This is unique across all networks, and takes the form of `<blockchain>-<network>`.
 * @export
 * @enum {string}
 */

export const NetworkIdentifier = {
    BaseSepolia: 'base-sepolia',
    BaseMainnet: 'base-mainnet',
    EthereumHolesky: 'ethereum-holesky',
    EthereumMainnet: 'ethereum-mainnet',
    PolygonMainnet: 'polygon-mainnet',
    SolanaDevnet: 'solana-devnet',
    SolanaMainnet: 'solana-mainnet',
    ArbitrumMainnet: 'arbitrum-mainnet'
} as const;

export type NetworkIdentifier = typeof NetworkIdentifier[keyof typeof NetworkIdentifier];


/**
 * A representation of an onchain stored name from name systems i.e. ENS or Basenames
 * @export
 * @interface OnchainName
 */
export interface OnchainName {
    /**
     * The ID for the NFT related to this name
     * @type {string}
     * @memberof OnchainName
     */
    'token_id': string;
    /**
     * The onchain address of the owner of the name
     * @type {string}
     * @memberof OnchainName
     */
    'owner_address': string;
    /**
     * The onchain address of the manager of the name
     * @type {string}
     * @memberof OnchainName
     */
    'manager_address': string;
    /**
     * The primary onchain address of the name
     * @type {string}
     * @memberof OnchainName
     */
    'primary_address'?: string;
    /**
     * The readable format for the name in complete form
     * @type {string}
     * @memberof OnchainName
     */
    'domain': string;
    /**
     * The visual representation attached to this name
     * @type {string}
     * @memberof OnchainName
     */
    'avatar'?: string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof OnchainName
     */
    'network_id': string;
    /**
     * The expiration date for this name\'s ownership
     * @type {string}
     * @memberof OnchainName
     */
    'expires_at': string;
    /**
     * The metadata attached to this name
     * @type {{ [key: string]: string; }}
     * @memberof OnchainName
     */
    'text_records'?: { [key: string]: string; };
    /**
     * Whether this name is the primary name for the owner (This is when the ETH coin address for this name is equal to the primary_address. More info here https://docs.ens.domains/ensip/19)
     * @type {boolean}
     * @memberof OnchainName
     */
    'is_primary': boolean;
}
/**
 * A list of onchain events with pagination information
 * @export
 * @interface OnchainNameList
 */
export interface OnchainNameList {
    /**
     * A list of onchain name objects
     * @type {Array<OnchainName>}
     * @memberof OnchainNameList
     */
    'data': Array<OnchainName>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof OnchainNameList
     */
    'has_more'?: boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof OnchainNameList
     */
    'next_page': string;
    /**
     * The total number of payload signatures for the address.
     * @type {number}
     * @memberof OnchainNameList
     */
    'total_count'?: number;
}
/**
 * A payload signed by an address.
 * @export
 * @interface PayloadSignature
 */
export interface PayloadSignature {
    /**
     * The ID of the payload signature.
     * @type {string}
     * @memberof PayloadSignature
     */
    'payload_signature_id': string;
    /**
     * The ID of the wallet that owns the address.
     * @type {string}
     * @memberof PayloadSignature
     */
    'wallet_id': string;
    /**
     * The onchain address of the signer.
     * @type {string}
     * @memberof PayloadSignature
     */
    'address_id': string;
    /**
     * The unsigned payload. This is the payload that needs to be signed by the signer address.
     * @type {string}
     * @memberof PayloadSignature
     */
    'unsigned_payload': string;
    /**
     * The signature of the payload.
     * @type {string}
     * @memberof PayloadSignature
     */
    'signature'?: string;
    /**
     * The status of the payload signature.
     * @type {string}
     * @memberof PayloadSignature
     */
    'status': PayloadSignatureStatusEnum;
}

export const PayloadSignatureStatusEnum = {
    Pending: 'pending',
    Signed: 'signed',
    Failed: 'failed'
} as const;

export type PayloadSignatureStatusEnum = typeof PayloadSignatureStatusEnum[keyof typeof PayloadSignatureStatusEnum];

/**
 * 
 * @export
 * @interface PayloadSignatureList
 */
export interface PayloadSignatureList {
    /**
     * 
     * @type {Array<PayloadSignature>}
     * @memberof PayloadSignatureList
     */
    'data': Array<PayloadSignature>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof PayloadSignatureList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof PayloadSignatureList
     */
    'next_page': string;
    /**
     * The total number of payload signatures for the address.
     * @type {number}
     * @memberof PayloadSignatureList
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface ReadContractRequest
 */
export interface ReadContractRequest {
    /**
     * The name of the contract method to call
     * @type {string}
     * @memberof ReadContractRequest
     */
    'method': string;
    /**
     * The JSON-encoded arguments to pass to the contract method. The keys should be the argument names and the values should be the argument values.
     * @type {string}
     * @memberof ReadContractRequest
     */
    'args': string;
    /**
     * The JSON-encoded ABI of the contract method (optional, will use cached ABI if not provided)
     * @type {string}
     * @memberof ReadContractRequest
     */
    'abi'?: string;
}
/**
 * Smart Contract data to be registered
 * @export
 * @interface RegisterSmartContractRequest
 */
export interface RegisterSmartContractRequest {
    /**
     * ABI of the smart contract
     * @type {string}
     * @memberof RegisterSmartContractRequest
     */
    'abi': string;
    /**
     * Name of the smart contract
     * @type {string}
     * @memberof RegisterSmartContractRequest
     */
    'contract_name'?: string;
}
/**
 * An event representing a seed creation.
 * @export
 * @interface SeedCreationEvent
 */
export interface SeedCreationEvent {
    /**
     * The ID of the wallet that the server-signer should create the seed for
     * @type {string}
     * @memberof SeedCreationEvent
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SeedCreationEvent
     */
    'wallet_user_id': string;
}
/**
 * The result to a SeedCreationEvent.
 * @export
 * @interface SeedCreationEventResult
 */
export interface SeedCreationEventResult {
    /**
     * The ID of the wallet that the seed was created for
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'wallet_user_id': string;
    /**
     * The extended public key for the first master key derived from seed.
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'extended_public_key': string;
    /**
     * The ID of the seed in Server-Signer used to generate the extended public key.
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'seed_id': string;
}
/**
 * A Server-Signer assigned to sign transactions in a wallet.
 * @export
 * @interface ServerSigner
 */
export interface ServerSigner {
    /**
     * The ID of the server-signer
     * @type {string}
     * @memberof ServerSigner
     */
    'server_signer_id': string;
    /**
     * The IDs of the wallets that the server-signer can sign for
     * @type {Array<string>}
     * @memberof ServerSigner
     */
    'wallets'?: Array<string>;
    /**
     * Whether the Server-Signer uses MPC.
     * @type {boolean}
     * @memberof ServerSigner
     */
    'is_mpc': boolean;
}
/**
 * An event that is waiting to be processed by a Server-Signer.
 * @export
 * @interface ServerSignerEvent
 */
export interface ServerSignerEvent {
    /**
     * The ID of the server-signer that the event is for
     * @type {string}
     * @memberof ServerSignerEvent
     */
    'server_signer_id': string;
    /**
     * 
     * @type {ServerSignerEventEvent}
     * @memberof ServerSignerEvent
     */
    'event': ServerSignerEventEvent;
}
/**
 * @type ServerSignerEventEvent
 * @export
 */
export type ServerSignerEventEvent = SeedCreationEvent | SignatureCreationEvent;

/**
 * 
 * @export
 * @interface ServerSignerEventList
 */
export interface ServerSignerEventList {
    /**
     * 
     * @type {Array<ServerSignerEvent>}
     * @memberof ServerSignerEventList
     */
    'data': Array<ServerSignerEvent>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ServerSignerEventList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ServerSignerEventList
     */
    'next_page': string;
    /**
     * The total number of events for the server signer.
     * @type {number}
     * @memberof ServerSignerEventList
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface ServerSignerList
 */
export interface ServerSignerList {
    /**
     * 
     * @type {Array<ServerSigner>}
     * @memberof ServerSignerList
     */
    'data': Array<ServerSigner>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ServerSignerList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ServerSignerList
     */
    'next_page': string;
    /**
     * The total number of server-signers for the project.
     * @type {number}
     * @memberof ServerSignerList
     */
    'total_count': number;
}
/**
 * An event representing a signature creation.
 * @export
 * @interface SignatureCreationEvent
 */
export interface SignatureCreationEvent {
    /**
     * The ID of the seed that the server-signer should create the signature for
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'seed_id': string;
    /**
     * The ID of the wallet the signature is for
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'wallet_user_id': string;
    /**
     * The ID of the address the transfer belongs to
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'address_id': string;
    /**
     * The index of the address that the server-signer should sign with
     * @type {number}
     * @memberof SignatureCreationEvent
     */
    'address_index': number;
    /**
     * The payload that the server-signer should sign
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'signing_payload': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof SignatureCreationEvent
     */
    'transaction_type': TransactionType;
    /**
     * The ID of the transaction that the server-signer should sign
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'transaction_id': string;
}


/**
 * The result to a SignatureCreationEvent.
 * @export
 * @interface SignatureCreationEventResult
 */
export interface SignatureCreationEventResult {
    /**
     * The ID of the wallet that the event was created for.
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'wallet_user_id': string;
    /**
     * The ID of the address the transfer belongs to
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'address_id': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof SignatureCreationEventResult
     */
    'transaction_type': TransactionType;
    /**
     * The ID of the transaction that the Server-Signer has signed for
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'transaction_id': string;
    /**
     * The signature created by the server-signer.
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'signature': string;
}


/**
 * Signed voluntary exit message metadata to be provided to beacon chain to exit a validator.
 * @export
 * @interface SignedVoluntaryExitMessageMetadata
 */
export interface SignedVoluntaryExitMessageMetadata {
    /**
     * The public key of the validator associated with the exit message.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'validator_pub_key': string;
    /**
     * The current fork version of the Ethereum beacon chain.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'fork': string;
    /**
     * A base64 encoded version of a json string representing a voluntary exit message.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'signed_voluntary_exit': string;
}
/**
 * Represents a smart contract on the blockchain
 * @export
 * @interface SmartContract
 */
export interface SmartContract {
    /**
     * The unique identifier of the smart contract.
     * @type {string}
     * @memberof SmartContract
     */
    'smart_contract_id': string;
    /**
     * The name of the blockchain network
     * @type {string}
     * @memberof SmartContract
     */
    'network_id': string;
    /**
     * The ID of the wallet that deployed the smart contract. If this smart contract was deployed externally, this will be omitted.
     * @type {string}
     * @memberof SmartContract
     */
    'wallet_id'?: string;
    /**
     * The EVM address of the smart contract
     * @type {string}
     * @memberof SmartContract
     */
    'contract_address': string;
    /**
     * The name of the smart contract
     * @type {string}
     * @memberof SmartContract
     */
    'contract_name': string;
    /**
     * The EVM address of the account that deployed the smart contract. If this smart contract was deployed externally, this will be omitted.
     * @type {string}
     * @memberof SmartContract
     */
    'deployer_address'?: string;
    /**
     * 
     * @type {SmartContractType}
     * @memberof SmartContract
     */
    'type': SmartContractType;
    /**
     * 
     * @type {SmartContractOptions}
     * @memberof SmartContract
     */
    'options'?: SmartContractOptions;
    /**
     * The JSON-encoded ABI of the contract
     * @type {string}
     * @memberof SmartContract
     */
    'abi': string;
    /**
     * 
     * @type {Transaction}
     * @memberof SmartContract
     */
    'transaction'?: Transaction;
    /**
     * Whether the smart contract was deployed externally. If true, the deployer_address and transaction will be omitted.
     * @type {boolean}
     * @memberof SmartContract
     */
    'is_external': boolean;
    /**
     * The ID of the compiled smart contract that was used to deploy this contract
     * @type {string}
     * @memberof SmartContract
     */
    'compiled_smart_contract_id'?: string;
}


/**
 * Represents an event triggered by a smart contract activity on the blockchain. Contains information about the function, transaction, block, and involved addresses.
 * @export
 * @interface SmartContractActivityEvent
 */
export interface SmartContractActivityEvent {
    /**
     * Unique identifier for the webhook that triggered this event.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'webhookId'?: string;
    /**
     * Type of event, in this case, an ERC-721 token transfer.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'eventType'?: string;
    /**
     * Blockchain network where the event occurred.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'network'?: string;
    /**
     * Name of the project this smart contract belongs to.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'projectName'?: string;
    /**
     * Name of the contract.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'contractName'?: string;
    /**
     * Name of the function.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'func'?: string;
    /**
     * Signature of the function.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'sig'?: string;
    /**
     * First 4 bytes of the Transaction, a unique ID.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'fourBytes'?: string;
    /**
     * Address of the smart contract.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'contractAddress'?: string;
    /**
     * Hash of the block containing the transaction.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'blockHash'?: string;
    /**
     * Number of the block containing the transaction.
     * @type {number}
     * @memberof SmartContractActivityEvent
     */
    'blockNumber'?: number;
    /**
     * Timestamp when the block was mined.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'blockTime'?: string;
    /**
     * Hash of the transaction that triggered the event.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'transactionHash'?: string;
    /**
     * Position of the transaction within the block.
     * @type {number}
     * @memberof SmartContractActivityEvent
     */
    'transactionIndex'?: number;
    /**
     * Position of the event log within the transaction.
     * @type {number}
     * @memberof SmartContractActivityEvent
     */
    'logIndex'?: number;
    /**
     * Address of the initiator in the transfer.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'from'?: string;
    /**
     * Address of the recipient in the transfer.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'to'?: string;
    /**
     * Amount of tokens transferred, typically in the smallest unit (e.g., wei for Ethereum).
     * @type {number}
     * @memberof SmartContractActivityEvent
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface SmartContractList
 */
export interface SmartContractList {
    /**
     * 
     * @type {Array<SmartContract>}
     * @memberof SmartContractList
     */
    'data': Array<SmartContract>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof SmartContractList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof SmartContractList
     */
    'next_page': string;
}
/**
 * @type SmartContractOptions
 * Options for smart contract creation
 * @export
 */
export type SmartContractOptions = MultiTokenContractOptions | NFTContractOptions | TokenContractOptions | string;

/**
 * The type of the smart contract.
 * @export
 * @enum {string}
 */

export const SmartContractType = {
    Erc20: 'erc20',
    Erc721: 'erc721',
    Erc1155: 'erc1155',
    Custom: 'custom'
} as const;

export type SmartContractType = typeof SmartContractType[keyof typeof SmartContractType];


/**
 * 
 * @export
 * @interface SolidityValue
 */
export interface SolidityValue {
    /**
     * 
     * @type {string}
     * @memberof SolidityValue
     */
    'type': SolidityValueTypeEnum;
    /**
     * The field name for tuple types. Not used for other types.
     * @type {string}
     * @memberof SolidityValue
     */
    'name'?: string;
    /**
     * The value as a string for simple types. Not used for complex types (array, tuple).
     * @type {string}
     * @memberof SolidityValue
     */
    'value'?: string;
    /**
     * For array and tuple types, the components of the value
     * @type {Array<SolidityValue>}
     * @memberof SolidityValue
     */
    'values'?: Array<SolidityValue>;
}

export const SolidityValueTypeEnum = {
    Uint8: 'uint8',
    Uint16: 'uint16',
    Uint32: 'uint32',
    Uint64: 'uint64',
    Uint128: 'uint128',
    Uint160: 'uint160',
    Uint256: 'uint256',
    Int8: 'int8',
    Int16: 'int16',
    Int24: 'int24',
    Int32: 'int32',
    Int56: 'int56',
    Int64: 'int64',
    Int128: 'int128',
    Int256: 'int256',
    Address: 'address',
    Bool: 'bool',
    String: 'string',
    Bytes: 'bytes',
    Bytes1: 'bytes1',
    Bytes2: 'bytes2',
    Bytes3: 'bytes3',
    Bytes4: 'bytes4',
    Bytes5: 'bytes5',
    Bytes6: 'bytes6',
    Bytes7: 'bytes7',
    Bytes8: 'bytes8',
    Bytes9: 'bytes9',
    Bytes10: 'bytes10',
    Bytes11: 'bytes11',
    Bytes12: 'bytes12',
    Bytes13: 'bytes13',
    Bytes14: 'bytes14',
    Bytes15: 'bytes15',
    Bytes16: 'bytes16',
    Bytes17: 'bytes17',
    Bytes18: 'bytes18',
    Bytes19: 'bytes19',
    Bytes20: 'bytes20',
    Bytes21: 'bytes21',
    Bytes22: 'bytes22',
    Bytes23: 'bytes23',
    Bytes24: 'bytes24',
    Bytes25: 'bytes25',
    Bytes26: 'bytes26',
    Bytes27: 'bytes27',
    Bytes28: 'bytes28',
    Bytes29: 'bytes29',
    Bytes30: 'bytes30',
    Bytes31: 'bytes31',
    Bytes32: 'bytes32',
    Array: 'array',
    Tuple: 'tuple'
} as const;

export type SolidityValueTypeEnum = typeof SolidityValueTypeEnum[keyof typeof SolidityValueTypeEnum];

/**
 * An onchain sponsored gasless send.
 * @export
 * @interface SponsoredSend
 */
export interface SponsoredSend {
    /**
     * The onchain address of the recipient
     * @type {string}
     * @memberof SponsoredSend
     */
    'to_address_id': string;
    /**
     * The raw typed data for the sponsored send
     * @type {string}
     * @memberof SponsoredSend
     */
    'raw_typed_data': string;
    /**
     * The typed data hash for the sponsored send. This is the typed data hash that needs to be signed by the sender.
     * @type {string}
     * @memberof SponsoredSend
     */
    'typed_data_hash': string;
    /**
     * The signed hash of the sponsored send typed data.
     * @type {string}
     * @memberof SponsoredSend
     */
    'signature'?: string;
    /**
     * The hash of the onchain sponsored send transaction
     * @type {string}
     * @memberof SponsoredSend
     */
    'transaction_hash'?: string;
    /**
     * The link to view the transaction on a block explorer. This is optional and may not be present for all transactions.
     * @type {string}
     * @memberof SponsoredSend
     */
    'transaction_link'?: string;
    /**
     * The status of the sponsored send
     * @type {string}
     * @memberof SponsoredSend
     */
    'status': SponsoredSendStatusEnum;
}

export const SponsoredSendStatusEnum = {
    Pending: 'pending',
    Signed: 'signed',
    Submitted: 'submitted',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type SponsoredSendStatusEnum = typeof SponsoredSendStatusEnum[keyof typeof SponsoredSendStatusEnum];

/**
 * The staking balances for an address.
 * @export
 * @interface StakingBalance
 */
export interface StakingBalance {
    /**
     * The onchain address for which the staking balances are being fetched.
     * @type {string}
     * @memberof StakingBalance
     */
    'address': string;
    /**
     * The timestamp of the staking balance in UTC.
     * @type {string}
     * @memberof StakingBalance
     */
    'date': string;
    /**
     * 
     * @type {Balance}
     * @memberof StakingBalance
     */
    'bonded_stake': Balance;
    /**
     * 
     * @type {Balance}
     * @memberof StakingBalance
     */
    'unbonded_balance': Balance;
    /**
     * The type of staking participation.
     * @type {string}
     * @memberof StakingBalance
     */
    'participant_type': string;
}
/**
 * Context needed to perform a staking operation
 * @export
 * @interface StakingContext
 */
export interface StakingContext {
    /**
     * 
     * @type {StakingContextContext}
     * @memberof StakingContext
     */
    'context': StakingContextContext;
}
/**
 * 
 * @export
 * @interface StakingContextContext
 */
export interface StakingContextContext {
    /**
     * 
     * @type {Balance}
     * @memberof StakingContextContext
     */
    'stakeable_balance': Balance;
    /**
     * 
     * @type {Balance}
     * @memberof StakingContextContext
     */
    'unstakeable_balance': Balance;
    /**
     * 
     * @type {Balance}
     * @memberof StakingContextContext
     */
    'claimable_balance': Balance;
}
/**
 * A list of onchain transactions to help realize a staking action.
 * @export
 * @interface StakingOperation
 */
export interface StakingOperation {
    /**
     * The unique ID of the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'id': string;
    /**
     * The ID of the wallet that owns the address.
     * @type {string}
     * @memberof StakingOperation
     */
    'wallet_id'?: string;
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof StakingOperation
     */
    'network_id': string;
    /**
     * The onchain address orchestrating the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'address_id': string;
    /**
     * The status of the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'status': StakingOperationStatusEnum;
    /**
     * The transaction(s) that will execute the staking operation onchain.
     * @type {Array<Transaction>}
     * @memberof StakingOperation
     */
    'transactions': Array<Transaction>;
    /**
     * 
     * @type {StakingOperationMetadata}
     * @memberof StakingOperation
     */
    'metadata'?: StakingOperationMetadata;
}

export const StakingOperationStatusEnum = {
    Initialized: 'initialized',
    Complete: 'complete',
    Failed: 'failed',
    Unspecified: 'unspecified'
} as const;

export type StakingOperationStatusEnum = typeof StakingOperationStatusEnum[keyof typeof StakingOperationStatusEnum];

/**
 * @type StakingOperationMetadata
 * @export
 */
export type StakingOperationMetadata = Array<SignedVoluntaryExitMessageMetadata>;

/**
 * The staking rewards for an address.
 * @export
 * @interface StakingReward
 */
export interface StakingReward {
    /**
     * The onchain address for which the staking rewards are being fetched.
     * @type {string}
     * @memberof StakingReward
     */
    'address_id': string;
    /**
     * The timestamp of the reward in UTC.
     * @type {string}
     * @memberof StakingReward
     */
    'date': string;
    /**
     * The reward amount in requested \"format\". Default is USD.
     * @type {string}
     * @memberof StakingReward
     */
    'amount': string;
    /**
     * The state of the reward.
     * @type {string}
     * @memberof StakingReward
     */
    'state': StakingRewardStateEnum;
    /**
     * 
     * @type {StakingRewardFormat}
     * @memberof StakingReward
     */
    'format': StakingRewardFormat;
    /**
     * 
     * @type {StakingRewardUSDValue}
     * @memberof StakingReward
     */
    'usd_value': StakingRewardUSDValue;
}

export const StakingRewardStateEnum = {
    Pending: 'pending',
    Distributed: 'distributed'
} as const;

export type StakingRewardStateEnum = typeof StakingRewardStateEnum[keyof typeof StakingRewardStateEnum];

/**
 * The format in which the rewards are to be fetched i.e native or in equivalent USD
 * @export
 * @enum {string}
 */

export const StakingRewardFormat = {
    Usd: 'usd',
    Native: 'native'
} as const;

export type StakingRewardFormat = typeof StakingRewardFormat[keyof typeof StakingRewardFormat];


/**
 * The USD value of the reward
 * @export
 * @interface StakingRewardUSDValue
 */
export interface StakingRewardUSDValue {
    /**
     * The value of the reward in USD
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'amount': string;
    /**
     * The conversion price from native currency to USD
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'conversion_price': string;
    /**
     * The time of the conversion in UTC.
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'conversion_time': string;
}
/**
 * Options for token contract creation
 * @export
 * @interface TokenContractOptions
 */
export interface TokenContractOptions {
    /**
     * The name of the token
     * @type {string}
     * @memberof TokenContractOptions
     */
    'name': string;
    /**
     * The symbol of the token
     * @type {string}
     * @memberof TokenContractOptions
     */
    'symbol': string;
    /**
     * The total supply of the token denominated in the whole amount of the token.
     * @type {string}
     * @memberof TokenContractOptions
     */
    'total_supply': string;
}
/**
 * The type of the token transfer.
 * @export
 * @enum {string}
 */

export const TokenTransferType = {
    Erc20: 'erc20',
    Erc721: 'erc721',
    Erc1155: 'erc1155',
    Unknown: 'unknown'
} as const;

export type TokenTransferType = typeof TokenTransferType[keyof typeof TokenTransferType];


/**
 * A trade of an asset to another asset
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Trade
     */
    'network_id': string;
    /**
     * The ID of the wallet that owns the from address
     * @type {string}
     * @memberof Trade
     */
    'wallet_id': string;
    /**
     * The onchain address of the sender
     * @type {string}
     * @memberof Trade
     */
    'address_id': string;
    /**
     * The ID of the trade
     * @type {string}
     * @memberof Trade
     */
    'trade_id': string;
    /**
     * The amount of the from asset to be traded (in atomic units of the from asset)
     * @type {string}
     * @memberof Trade
     */
    'from_amount': string;
    /**
     * 
     * @type {Asset}
     * @memberof Trade
     */
    'from_asset': Asset;
    /**
     * The amount of the to asset that will be received (in atomic units of the to asset)
     * @type {string}
     * @memberof Trade
     */
    'to_amount': string;
    /**
     * 
     * @type {Asset}
     * @memberof Trade
     */
    'to_asset': Asset;
    /**
     * 
     * @type {Transaction}
     * @memberof Trade
     */
    'transaction': Transaction;
    /**
     * 
     * @type {Transaction}
     * @memberof Trade
     */
    'approve_transaction'?: Transaction;
}
/**
 * 
 * @export
 * @interface TradeList
 */
export interface TradeList {
    /**
     * 
     * @type {Array<Trade>}
     * @memberof TradeList
     */
    'data': Array<Trade>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof TradeList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof TradeList
     */
    'next_page': string;
    /**
     * The total number of trades for the address in the wallet.
     * @type {number}
     * @memberof TradeList
     */
    'total_count': number;
}
/**
 * An onchain transaction.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof Transaction
     */
    'network_id': string;
    /**
     * The hash of the block at which the transaction was recorded.
     * @type {string}
     * @memberof Transaction
     */
    'block_hash'?: string;
    /**
     * The block height at which the transaction was recorded.
     * @type {string}
     * @memberof Transaction
     */
    'block_height'?: string;
    /**
     * The onchain address of the sender.
     * @type {string}
     * @memberof Transaction
     */
    'from_address_id': string;
    /**
     * The onchain address of the recipient.
     * @type {string}
     * @memberof Transaction
     */
    'to_address_id'?: string;
    /**
     * The unsigned payload of the transaction. This is the payload that needs to be signed by the sender.
     * @type {string}
     * @memberof Transaction
     */
    'unsigned_payload': string;
    /**
     * The signed payload of the transaction. This is the payload that has been signed by the sender.
     * @type {string}
     * @memberof Transaction
     */
    'signed_payload'?: string;
    /**
     * The hash of the transaction.
     * @type {string}
     * @memberof Transaction
     */
    'transaction_hash'?: string;
    /**
     * The link to view the transaction on a block explorer. This is optional and may not be present for all transactions.
     * @type {string}
     * @memberof Transaction
     */
    'transaction_link'?: string;
    /**
     * The status of the transaction.
     * @type {string}
     * @memberof Transaction
     */
    'status': TransactionStatusEnum;
    /**
     * 
     * @type {TransactionContent}
     * @memberof Transaction
     */
    'content'?: TransactionContent;
}

export const TransactionStatusEnum = {
    Pending: 'pending',
    Signed: 'signed',
    Broadcast: 'broadcast',
    Complete: 'complete',
    Failed: 'failed',
    Unspecified: 'unspecified'
} as const;

export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];

/**
 * @type TransactionContent
 * @export
 */
export type TransactionContent = EthereumTransaction;

/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Transfer: 'transfer'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * A transfer of an asset from one address to another
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Transfer
     */
    'network_id': string;
    /**
     * The ID of the wallet that owns the from address
     * @type {string}
     * @memberof Transfer
     */
    'wallet_id': string;
    /**
     * The onchain address of the sender
     * @type {string}
     * @memberof Transfer
     */
    'address_id': string;
    /**
     * The onchain address of the recipient
     * @type {string}
     * @memberof Transfer
     */
    'destination': string;
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof Transfer
     */
    'amount': string;
    /**
     * The ID of the asset being transferred. Use `asset.asset_id` instead.
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'asset_id': string;
    /**
     * 
     * @type {Asset}
     * @memberof Transfer
     */
    'asset': Asset;
    /**
     * The ID of the transfer
     * @type {string}
     * @memberof Transfer
     */
    'transfer_id': string;
    /**
     * 
     * @type {Transaction}
     * @memberof Transfer
     */
    'transaction'?: Transaction;
    /**
     * 
     * @type {SponsoredSend}
     * @memberof Transfer
     */
    'sponsored_send'?: SponsoredSend;
    /**
     * The unsigned payload of the transfer. This is the payload that needs to be signed by the sender.
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'unsigned_payload'?: string;
    /**
     * The signed payload of the transfer. This is the payload that has been signed by the sender.
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'signed_payload'?: string;
    /**
     * The hash of the transfer transaction
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'transaction_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'status'?: string;
    /**
     * Whether the transfer uses sponsored gas
     * @type {boolean}
     * @memberof Transfer
     */
    'gasless': boolean;
}
/**
 * 
 * @export
 * @interface TransferList
 */
export interface TransferList {
    /**
     * 
     * @type {Array<Transfer>}
     * @memberof TransferList
     */
    'data': Array<Transfer>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof TransferList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof TransferList
     */
    'next_page': string;
    /**
     * The total number of transfers for the address in the wallet.
     * @type {number}
     * @memberof TransferList
     */
    'total_count': number;
}
/**
 * Smart Contract data to be updated
 * @export
 * @interface UpdateSmartContractRequest
 */
export interface UpdateSmartContractRequest {
    /**
     * ABI of the smart contract
     * @type {string}
     * @memberof UpdateSmartContractRequest
     */
    'abi'?: string;
    /**
     * Name of the smart contract
     * @type {string}
     * @memberof UpdateSmartContractRequest
     */
    'contract_name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWebhookRequest
 */
export interface UpdateWebhookRequest {
    /**
     * 
     * @type {WebhookEventTypeFilter}
     * @memberof UpdateWebhookRequest
     */
    'event_type_filter'?: WebhookEventTypeFilter;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof UpdateWebhookRequest
     */
    'event_filters'?: Array<WebhookEventFilter>;
    /**
     * The Webhook uri that updates to
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'notification_uri'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * The ID of the user
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'display_name'?: string;
}
/**
 * A validator onchain.
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * The publicly identifiable unique id of the validator. This can be the public key for Ethereum validators and maybe an address for some other network.
     * @type {string}
     * @memberof Validator
     */
    'validator_id': string;
    /**
     * The ID of the blockchain network to which the Validator belongs.
     * @type {string}
     * @memberof Validator
     */
    'network_id': string;
    /**
     * The ID of the asset that the validator helps stake.
     * @type {string}
     * @memberof Validator
     */
    'asset_id': string;
    /**
     * 
     * @type {ValidatorStatus}
     * @memberof Validator
     */
    'status': ValidatorStatus;
    /**
     * 
     * @type {ValidatorDetails}
     * @memberof Validator
     */
    'details'?: ValidatorDetails;
}


/**
 * @type ValidatorDetails
 * @export
 */
export type ValidatorDetails = EthereumValidatorMetadata;

/**
 * 
 * @export
 * @interface ValidatorList
 */
export interface ValidatorList {
    /**
     * 
     * @type {Array<Validator>}
     * @memberof ValidatorList
     */
    'data': Array<Validator>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ValidatorList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ValidatorList
     */
    'next_page': string;
}
/**
 * The status of the validator.
 * @export
 * @enum {string}
 */

export const ValidatorStatus = {
    Unknown: 'unknown',
    Provisioning: 'provisioning',
    Provisioned: 'provisioned',
    Deposited: 'deposited',
    PendingActivation: 'pending_activation',
    Active: 'active',
    Exiting: 'exiting',
    Exited: 'exited',
    WithdrawalAvailable: 'withdrawal_available',
    WithdrawalComplete: 'withdrawal_complete',
    ActiveSlashed: 'active_slashed',
    ExitedSlashed: 'exited_slashed',
    Reaped: 'reaped'
} as const;

export type ValidatorStatus = typeof ValidatorStatus[keyof typeof ValidatorStatus];


/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * The server-assigned ID for the wallet.
     * @type {string}
     * @memberof Wallet
     */
    'id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Wallet
     */
    'network_id': string;
    /**
     * 
     * @type {Address}
     * @memberof Wallet
     */
    'default_address'?: Address;
    /**
     * 
     * @type {FeatureSet}
     * @memberof Wallet
     */
    'feature_set': FeatureSet;
    /**
     * The status of the Server-Signer for the wallet if present.
     * @type {string}
     * @memberof Wallet
     */
    'server_signer_status'?: WalletServerSignerStatusEnum;
}

export const WalletServerSignerStatusEnum = {
    PendingSeedCreation: 'pending_seed_creation',
    ActiveSeed: 'active_seed'
} as const;

export type WalletServerSignerStatusEnum = typeof WalletServerSignerStatusEnum[keyof typeof WalletServerSignerStatusEnum];

/**
 * Paginated list of wallets
 * @export
 * @interface WalletList
 */
export interface WalletList {
    /**
     * 
     * @type {Array<Wallet>}
     * @memberof WalletList
     */
    'data': Array<Wallet>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof WalletList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof WalletList
     */
    'next_page': string;
    /**
     * The total number of wallets
     * @type {number}
     * @memberof WalletList
     */
    'total_count': number;
}
/**
 * Webhook that is used for getting notifications when monitored events occur.
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Identifier of the webhook.
     * @type {string}
     * @memberof Webhook
     */
    'id'?: string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Webhook
     */
    'network_id'?: string;
    /**
     * 
     * @type {WebhookEventType}
     * @memberof Webhook
     */
    'event_type'?: WebhookEventType;
    /**
     * 
     * @type {WebhookEventTypeFilter}
     * @memberof Webhook
     */
    'event_type_filter'?: WebhookEventTypeFilter;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof Webhook
     */
    'event_filters'?: Array<WebhookEventFilter>;
    /**
     * The URL to which the notifications will be sent.
     * @type {string}
     * @memberof Webhook
     */
    'notification_uri'?: string;
    /**
     * The date and time the webhook was created.
     * @type {string}
     * @memberof Webhook
     */
    'created_at'?: string;
    /**
     * The date and time the webhook was last updated.
     * @type {string}
     * @memberof Webhook
     */
    'updated_at'?: string;
    /**
     * The header that will contain the signature of the webhook payload.
     * @type {string}
     * @memberof Webhook
     */
    'signature_header'?: string;
}


/**
 * The event_filter parameter specifies the criteria to filter events from the blockchain. It allows filtering events by contract address, sender address and receiver address. For a single event filter, not all of the properties need to be presented.
 * @export
 * @interface WebhookEventFilter
 */
export interface WebhookEventFilter {
    /**
     * The onchain contract address of the token for which the events should be tracked.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'contract_address'?: string;
    /**
     * The onchain address of the sender. Set this filter to track all transfer events originating from your address.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'from_address'?: string;
    /**
     * The onchain address of the receiver. Set this filter to track all transfer events sent to your address.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'to_address'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookEventType = {
    Unspecified: 'unspecified',
    Erc20Transfer: 'erc20_transfer',
    Erc721Transfer: 'erc721_transfer',
    WalletActivity: 'wallet_activity',
    SmartContractEventActivity: 'smart_contract_event_activity'
} as const;

export type WebhookEventType = typeof WebhookEventType[keyof typeof WebhookEventType];


/**
 * @type WebhookEventTypeFilter
 * The event_type_filter parameter specifies the criteria to filter events based on event type.
 * @export
 */
export type WebhookEventTypeFilter = WebhookSmartContractEventFilter | WebhookWalletActivityFilter;

/**
 * 
 * @export
 * @interface WebhookList
 */
export interface WebhookList {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookList
     */
    'data': Array<Webhook>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof WebhookList
     */
    'has_more'?: boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof WebhookList
     */
    'next_page'?: string;
}
/**
 * Filter for smart contract events. This filter allows the client to specify smart contract addresses to monitor for activities such as contract function calls. 
 * @export
 * @interface WebhookSmartContractEventFilter
 */
export interface WebhookSmartContractEventFilter {
    /**
     * A list of smart contract addresses to filter on.
     * @type {Array<string>}
     * @memberof WebhookSmartContractEventFilter
     */
    'contract_addresses': Array<string>;
}
/**
 * Filter for wallet activity events. This filter allows the client to specify one or more wallet addresses to monitor for activities such as transactions, transfers, or other types of events that are associated with the specified addresses. 
 * @export
 * @interface WebhookWalletActivityFilter
 */
export interface WebhookWalletActivityFilter {
    /**
     * A list of wallet addresses to filter on.
     * @type {Array<string>}
     * @memberof WebhookWalletActivityFilter
     */
    'addresses'?: Array<string>;
    /**
     * The ID of the wallet that owns the webhook.
     * @type {string}
     * @memberof WebhookWalletActivityFilter
     */
    'wallet_id': string;
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress: async (walletId: string, createAddressRequest?: CreateAddressRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createAddress', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new payload signature with an address.
         * @summary Create a new payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to sign the payload with.
         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayloadSignature: async (walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createPayloadSignature', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createPayloadSignature', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPayloadSignatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress: async (walletId: string, addressId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getAddress', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getAddress', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressBalance: async (walletId: string, addressId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getAddressBalance', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getAddressBalance', 'addressId', addressId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAddressBalance', 'assetId', assetId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances/{asset_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payload signature.
         * @summary Get payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that signed the payload.
         * @param {string} payloadSignatureId The ID of the payload signature to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayloadSignature: async (walletId: string, addressId: string, payloadSignatureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getPayloadSignature', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getPayloadSignature', 'addressId', addressId)
            // verify required parameter 'payloadSignatureId' is not null or undefined
            assertParamExists('getPayloadSignature', 'payloadSignatureId', payloadSignatureId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures/{payload_signature_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"payload_signature_id"}}`, encodeURIComponent(String(payloadSignatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressBalances: async (walletId: string, addressId: string, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listAddressBalances', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listAddressBalances', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses: async (walletId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listAddresses', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List payload signatures for an address.
         * @summary List payload signatures for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayloadSignatures: async (walletId: string, addressId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listPayloadSignatures', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listPayloadSignatures', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        requestFaucetFunds: async (walletId: string, addressId: string, assetId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('requestFaucetFunds', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('requestFaucetFunds', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/faucet`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(walletId, createAddressRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.createAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new payload signature with an address.
         * @summary Create a new payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to sign the payload with.
         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayloadSignature(walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadSignature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.createPayloadSignature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(walletId, addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.getAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressBalance(walletId, addressId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.getAddressBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get payload signature.
         * @summary Get payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that signed the payload.
         * @param {string} payloadSignatureId The ID of the payload signature to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayloadSignature(walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadSignature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayloadSignature(walletId, addressId, payloadSignatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.getPayloadSignature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressBalances(walletId, addressId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.listAddressBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(walletId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.listAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List payload signatures for an address.
         * @summary List payload signatures for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayloadSignatures(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadSignatureList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayloadSignatures(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.listPayloadSignatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async requestFaucetFunds(walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFaucetFunds(walletId, addressId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.requestFaucetFunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.createAddress(walletId, createAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new payload signature with an address.
         * @summary Create a new payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to sign the payload with.
         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayloadSignature(walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignature> {
            return localVarFp.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.getAddress(walletId, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance> {
            return localVarFp.getAddressBalance(walletId, addressId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payload signature.
         * @summary Get payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that signed the payload.
         * @param {string} payloadSignatureId The ID of the payload signature to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayloadSignature(walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignature> {
            return localVarFp.getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList> {
            return localVarFp.listAddressBalances(walletId, addressId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressList> {
            return localVarFp.listAddresses(walletId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List payload signatures for an address.
         * @summary List payload signatures for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayloadSignatures(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignatureList> {
            return localVarFp.listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        requestFaucetFunds(walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction> {
            return localVarFp.requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - interface
 * @export
 * @interface AddressesApi
 */
export interface AddressesApiInterface {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<Address>;

    /**
     * Create a new payload signature with an address.
     * @summary Create a new payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to sign the payload with.
     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    createPayloadSignature(walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignature>;

    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<Address>;

    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;

    /**
     * Get payload signature.
     * @summary Get payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that signed the payload.
     * @param {string} payloadSignatureId The ID of the payload signature to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getPayloadSignature(walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignature>;

    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;

    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressList>;

    /**
     * List payload signatures for an address.
     * @summary List payload signatures for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    listPayloadSignatures(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignatureList>;

    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    requestFaucetFunds(walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;

}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI implements AddressesApiInterface {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).createAddress(walletId, createAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new payload signature with an address.
     * @summary Create a new payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to sign the payload with.
     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public createPayloadSignature(walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).getAddress(walletId, addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).getAddressBalance(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payload signature.
     * @summary Get payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that signed the payload.
     * @param {string} payloadSignatureId The ID of the payload signature to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getPayloadSignature(walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).listAddressBalances(walletId, addressId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).listAddresses(walletId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List payload signatures for an address.
     * @summary List payload signatures for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public listPayloadSignatures(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public requestFaucetFunds(walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (networkId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getAsset', 'networkId', networkId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAsset', 'assetId', assetId)
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(networkId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.getAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Asset> {
            return localVarFp.getAsset(networkId, assetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - interface
 * @export
 * @interface AssetsApi
 */
export interface AssetsApiInterface {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApiInterface
     */
    getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Asset>;

}

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI implements AssetsApiInterface {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).getAsset(networkId, assetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BalanceHistoryApi - axios parameter creator
 * @export
 */
export const BalanceHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressHistoricalBalance: async (networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listAddressHistoricalBalance', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listAddressHistoricalBalance', 'addressId', addressId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('listAddressHistoricalBalance', 'assetId', assetId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balance_history/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceHistoryApi - functional programming interface
 * @export
 */
export const BalanceHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressHistoricalBalanceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalanceHistoryApi.listAddressHistoricalBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BalanceHistoryApi - factory interface
 * @export
 */
export const BalanceHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceHistoryApiFp(configuration)
    return {
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressHistoricalBalanceList> {
            return localVarFp.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceHistoryApi - interface
 * @export
 * @interface BalanceHistoryApi
 */
export interface BalanceHistoryApiInterface {
    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceHistoryApiInterface
     */
    listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressHistoricalBalanceList>;

}

/**
 * BalanceHistoryApi - object-oriented interface
 * @export
 * @class BalanceHistoryApi
 * @extends {BaseAPI}
 */
export class BalanceHistoryApi extends BaseAPI implements BalanceHistoryApiInterface {
    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceHistoryApi
     */
    public listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return BalanceHistoryApiFp(this.configuration).listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContractEventsApi - axios parameter creator
 * @export
 */
export const ContractEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve events for a specific contract
         * @summary List contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {string} contractName Case-sensitive name of the specific contract within the project
         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractEvents: async (networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listContractEvents', 'networkId', networkId)
            // verify required parameter 'protocolName' is not null or undefined
            assertParamExists('listContractEvents', 'protocolName', protocolName)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('listContractEvents', 'contractAddress', contractAddress)
            // verify required parameter 'contractName' is not null or undefined
            assertParamExists('listContractEvents', 'contractName', contractName)
            // verify required parameter 'eventName' is not null or undefined
            assertParamExists('listContractEvents', 'eventName', eventName)
            // verify required parameter 'fromBlockHeight' is not null or undefined
            assertParamExists('listContractEvents', 'fromBlockHeight', fromBlockHeight)
            // verify required parameter 'toBlockHeight' is not null or undefined
            assertParamExists('listContractEvents', 'toBlockHeight', toBlockHeight)
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/events`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (protocolName !== undefined) {
                localVarQueryParameter['protocol_name'] = protocolName;
            }

            if (contractName !== undefined) {
                localVarQueryParameter['contract_name'] = contractName;
            }

            if (eventName !== undefined) {
                localVarQueryParameter['event_name'] = eventName;
            }

            if (fromBlockHeight !== undefined) {
                localVarQueryParameter['from_block_height'] = fromBlockHeight;
            }

            if (toBlockHeight !== undefined) {
                localVarQueryParameter['to_block_height'] = toBlockHeight;
            }

            if (nextPage !== undefined) {
                localVarQueryParameter['next_page'] = nextPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractEventsApi - functional programming interface
 * @export
 */
export const ContractEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve events for a specific contract
         * @summary List contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {string} contractName Case-sensitive name of the specific contract within the project
         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContractEvents(networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractEventsApi.listContractEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContractEventsApi - factory interface
 * @export
 */
export const ContractEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractEventsApiFp(configuration)
    return {
        /**
         * Retrieve events for a specific contract
         * @summary List contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {string} contractName Case-sensitive name of the specific contract within the project
         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractEvents(networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractEventList> {
            return localVarFp.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractEventsApi - interface
 * @export
 * @interface ContractEventsApi
 */
export interface ContractEventsApiInterface {
    /**
     * Retrieve events for a specific contract
     * @summary List contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {string} contractName Case-sensitive name of the specific contract within the project
     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractEventsApiInterface
     */
    listContractEvents(networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractEventList>;

}

/**
 * ContractEventsApi - object-oriented interface
 * @export
 * @class ContractEventsApi
 * @extends {BaseAPI}
 */
export class ContractEventsApi extends BaseAPI implements ContractEventsApiInterface {
    /**
     * Retrieve events for a specific contract
     * @summary List contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {string} contractName Case-sensitive name of the specific contract within the project
     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractEventsApi
     */
    public listContractEvents(networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig) {
        return ContractEventsApiFp(this.configuration).listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContractInvocationsApi - axios parameter creator
 * @export
 */
export const ContractInvocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcast a contract invocation.
         * @summary Broadcast a contract invocation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastContractInvocation: async (walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('broadcastContractInvocation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('broadcastContractInvocation', 'addressId', addressId)
            // verify required parameter 'contractInvocationId' is not null or undefined
            assertParamExists('broadcastContractInvocation', 'contractInvocationId', contractInvocationId)
            // verify required parameter 'broadcastContractInvocationRequest' is not null or undefined
            assertParamExists('broadcastContractInvocation', 'broadcastContractInvocationRequest', broadcastContractInvocationRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"contract_invocation_id"}}`, encodeURIComponent(String(contractInvocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastContractInvocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new contract invocation.
         * @summary Create a new contract invocation for an address.
         * @param {string} walletId The ID of the wallet the source address belongs to.
         * @param {string} addressId The ID of the address to invoke the contract from.
         * @param {CreateContractInvocationRequest} createContractInvocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractInvocation: async (walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createContractInvocation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createContractInvocation', 'addressId', addressId)
            // verify required parameter 'createContractInvocationRequest' is not null or undefined
            assertParamExists('createContractInvocation', 'createContractInvocationRequest', createContractInvocationRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContractInvocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a contract invocation by ID.
         * @summary Get a contract invocation by ID.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractInvocation: async (walletId: string, addressId: string, contractInvocationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getContractInvocation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getContractInvocation', 'addressId', addressId)
            // verify required parameter 'contractInvocationId' is not null or undefined
            assertParamExists('getContractInvocation', 'contractInvocationId', contractInvocationId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"contract_invocation_id"}}`, encodeURIComponent(String(contractInvocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List contract invocations for an address.
         * @summary List contract invocations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to list contract invocations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractInvocations: async (walletId: string, addressId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listContractInvocations', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listContractInvocations', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractInvocationsApi - functional programming interface
 * @export
 */
export const ContractInvocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractInvocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Broadcast a contract invocation.
         * @summary Broadcast a contract invocation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastContractInvocation(walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInvocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractInvocationsApi.broadcastContractInvocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new contract invocation.
         * @summary Create a new contract invocation for an address.
         * @param {string} walletId The ID of the wallet the source address belongs to.
         * @param {string} addressId The ID of the address to invoke the contract from.
         * @param {CreateContractInvocationRequest} createContractInvocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContractInvocation(walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInvocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractInvocation(walletId, addressId, createContractInvocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractInvocationsApi.createContractInvocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a contract invocation by ID.
         * @summary Get a contract invocation by ID.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractInvocation(walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInvocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractInvocation(walletId, addressId, contractInvocationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractInvocationsApi.getContractInvocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List contract invocations for an address.
         * @summary List contract invocations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to list contract invocations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContractInvocations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInvocationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractInvocations(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractInvocationsApi.listContractInvocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContractInvocationsApi - factory interface
 * @export
 */
export const ContractInvocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractInvocationsApiFp(configuration)
    return {
        /**
         * Broadcast a contract invocation.
         * @summary Broadcast a contract invocation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastContractInvocation(walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation> {
            return localVarFp.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new contract invocation.
         * @summary Create a new contract invocation for an address.
         * @param {string} walletId The ID of the wallet the source address belongs to.
         * @param {string} addressId The ID of the address to invoke the contract from.
         * @param {CreateContractInvocationRequest} createContractInvocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractInvocation(walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation> {
            return localVarFp.createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a contract invocation by ID.
         * @summary Get a contract invocation by ID.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractInvocation(walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation> {
            return localVarFp.getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List contract invocations for an address.
         * @summary List contract invocations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to list contract invocations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractInvocations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocationList> {
            return localVarFp.listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractInvocationsApi - interface
 * @export
 * @interface ContractInvocationsApi
 */
export interface ContractInvocationsApiInterface {
    /**
     * Broadcast a contract invocation.
     * @summary Broadcast a contract invocation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApiInterface
     */
    broadcastContractInvocation(walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;

    /**
     * Create a new contract invocation.
     * @summary Create a new contract invocation for an address.
     * @param {string} walletId The ID of the wallet the source address belongs to.
     * @param {string} addressId The ID of the address to invoke the contract from.
     * @param {CreateContractInvocationRequest} createContractInvocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApiInterface
     */
    createContractInvocation(walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;

    /**
     * Get a contract invocation by ID.
     * @summary Get a contract invocation by ID.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApiInterface
     */
    getContractInvocation(walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;

    /**
     * List contract invocations for an address.
     * @summary List contract invocations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to list contract invocations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApiInterface
     */
    listContractInvocations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocationList>;

}

/**
 * ContractInvocationsApi - object-oriented interface
 * @export
 * @class ContractInvocationsApi
 * @extends {BaseAPI}
 */
export class ContractInvocationsApi extends BaseAPI implements ContractInvocationsApiInterface {
    /**
     * Broadcast a contract invocation.
     * @summary Broadcast a contract invocation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    public broadcastContractInvocation(walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig) {
        return ContractInvocationsApiFp(this.configuration).broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new contract invocation.
     * @summary Create a new contract invocation for an address.
     * @param {string} walletId The ID of the wallet the source address belongs to.
     * @param {string} addressId The ID of the address to invoke the contract from.
     * @param {CreateContractInvocationRequest} createContractInvocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    public createContractInvocation(walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig) {
        return ContractInvocationsApiFp(this.configuration).createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a contract invocation by ID.
     * @summary Get a contract invocation by ID.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    public getContractInvocation(walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig) {
        return ContractInvocationsApiFp(this.configuration).getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List contract invocations for an address.
     * @summary List contract invocations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to list contract invocations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    public listContractInvocations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return ContractInvocationsApiFp(this.configuration).listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExternalAddressesApi - axios parameter creator
 * @export
 */
export const ExternalAddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcast an external address\'s transfer with a signed payload
         * @summary Broadcast an external address\' transfer
         * @param {string} networkId The ID of the network the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastExternalTransfer: async (networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('broadcastExternalTransfer', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('broadcastExternalTransfer', 'addressId', addressId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('broadcastExternalTransfer', 'transferId', transferId)
            // verify required parameter 'broadcastExternalTransferRequest' is not null or undefined
            assertParamExists('broadcastExternalTransfer', 'broadcastExternalTransferRequest', broadcastExternalTransferRequest)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastExternalTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer between addresses.
         * @summary Create a new transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateExternalTransferRequest} createExternalTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalTransfer: async (networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('createExternalTransfer', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createExternalTransfer', 'addressId', addressId)
            // verify required parameter 'createExternalTransferRequest' is not null or undefined
            assertParamExists('createExternalTransfer', 'createExternalTransferRequest', createExternalTransferRequest)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExternalTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalAddressBalance: async (networkId: string, addressId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getExternalAddressBalance', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getExternalAddressBalance', 'addressId', addressId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getExternalAddressBalance', 'assetId', assetId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an external address\' transfer by ID
         * @summary Get a external address\' transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTransfer: async (networkId: string, addressId: string, transferId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getExternalTransfer', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getExternalTransfer', 'addressId', addressId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('getExternalTransfer', 'transferId', transferId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers/{transfer_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a faucet transaction
         * @summary Get the status of a faucet transaction
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the faucet transaction for
         * @param {string} txHash The hash of the faucet transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaucetTransaction: async (networkId: string, addressId: string, txHash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getFaucetTransaction', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getFaucetTransaction', 'addressId', addressId)
            // verify required parameter 'txHash' is not null or undefined
            assertParamExists('getFaucetTransaction', 'txHash', txHash)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet/{tx_hash}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"tx_hash"}}`, encodeURIComponent(String(txHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExternalAddressBalances: async (networkId: string, addressId: string, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listExternalAddressBalances', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listExternalAddressBalances', 'addressId', addressId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestExternalFaucetFunds: async (networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('requestExternalFaucetFunds', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('requestExternalFaucetFunds', 'addressId', addressId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (skipWait !== undefined) {
                localVarQueryParameter['skip_wait'] = skipWait;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalAddressesApi - functional programming interface
 * @export
 */
export const ExternalAddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalAddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Broadcast an external address\'s transfer with a signed payload
         * @summary Broadcast an external address\' transfer
         * @param {string} networkId The ID of the network the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastExternalTransfer(networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.broadcastExternalTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new transfer between addresses.
         * @summary Create a new transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateExternalTransferRequest} createExternalTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalTransfer(networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalTransfer(networkId, addressId, createExternalTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.createExternalTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalAddressBalance(networkId, addressId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.getExternalAddressBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an external address\' transfer by ID
         * @summary Get a external address\' transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTransfer(networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTransfer(networkId, addressId, transferId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.getExternalTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of a faucet transaction
         * @summary Get the status of a faucet transaction
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the faucet transaction for
         * @param {string} txHash The hash of the faucet transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaucetTransaction(networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaucetTransaction(networkId, addressId, txHash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.getFaucetTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExternalAddressBalances(networkId, addressId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.listExternalAddressBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestExternalFaucetFunds(networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.requestExternalFaucetFunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExternalAddressesApi - factory interface
 * @export
 */
export const ExternalAddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalAddressesApiFp(configuration)
    return {
        /**
         * Broadcast an external address\'s transfer with a signed payload
         * @summary Broadcast an external address\' transfer
         * @param {string} networkId The ID of the network the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastExternalTransfer(networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer> {
            return localVarFp.broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer between addresses.
         * @summary Create a new transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateExternalTransferRequest} createExternalTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalTransfer(networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer> {
            return localVarFp.createExternalTransfer(networkId, addressId, createExternalTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance> {
            return localVarFp.getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an external address\' transfer by ID
         * @summary Get a external address\' transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTransfer(networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer> {
            return localVarFp.getExternalTransfer(networkId, addressId, transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a faucet transaction
         * @summary Get the status of a faucet transaction
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the faucet transaction for
         * @param {string} txHash The hash of the faucet transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaucetTransaction(networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction> {
            return localVarFp.getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList> {
            return localVarFp.listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestExternalFaucetFunds(networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction> {
            return localVarFp.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalAddressesApi - interface
 * @export
 * @interface ExternalAddressesApi
 */
export interface ExternalAddressesApiInterface {
    /**
     * Broadcast an external address\'s transfer with a signed payload
     * @summary Broadcast an external address\' transfer
     * @param {string} networkId The ID of the network the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    broadcastExternalTransfer(networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * Create a new transfer between addresses.
     * @summary Create a new transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateExternalTransferRequest} createExternalTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    createExternalTransfer(networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;

    /**
     * Get an external address\' transfer by ID
     * @summary Get a external address\' transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    getExternalTransfer(networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * Get the status of a faucet transaction
     * @summary Get the status of a faucet transaction
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the faucet transaction for
     * @param {string} txHash The hash of the faucet transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    getFaucetTransaction(networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;

    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;

    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    requestExternalFaucetFunds(networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;

}

/**
 * ExternalAddressesApi - object-oriented interface
 * @export
 * @class ExternalAddressesApi
 * @extends {BaseAPI}
 */
export class ExternalAddressesApi extends BaseAPI implements ExternalAddressesApiInterface {
    /**
     * Broadcast an external address\'s transfer with a signed payload
     * @summary Broadcast an external address\' transfer
     * @param {string} networkId The ID of the network the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public broadcastExternalTransfer(networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer between addresses.
     * @summary Create a new transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateExternalTransferRequest} createExternalTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public createExternalTransfer(networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).createExternalTransfer(networkId, addressId, createExternalTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an external address\' transfer by ID
     * @summary Get a external address\' transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public getExternalTransfer(networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).getExternalTransfer(networkId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a faucet transaction
     * @summary Get the status of a faucet transaction
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the faucet transaction for
     * @param {string} txHash The hash of the faucet transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public getFaucetTransaction(networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public requestExternalFaucetFunds(networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FundApi - axios parameter creator
 * @export
 */
export const FundApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new fund operation with an address.
         * @summary Create a new fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundOperationRequest} createFundOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundOperation: async (walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createFundOperation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createFundOperation', 'addressId', addressId)
            // verify required parameter 'createFundOperationRequest' is not null or undefined
            assertParamExists('createFundOperation', 'createFundOperationRequest', createFundOperationRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFundOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new fund operation with an address.
         * @summary Create a Fund Operation quote.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundQuoteRequest} createFundQuoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundQuote: async (walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createFundQuote', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createFundQuote', 'addressId', addressId)
            // verify required parameter 'createFundQuoteRequest' is not null or undefined
            assertParamExists('createFundQuote', 'createFundQuoteRequest', createFundQuoteRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/quote`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFundQuoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get fund operation.
         * @summary Get fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that created the fund operation.
         * @param {string} fundOperationId The ID of the fund operation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundOperation: async (walletId: string, addressId: string, fundOperationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getFundOperation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getFundOperation', 'addressId', addressId)
            // verify required parameter 'fundOperationId' is not null or undefined
            assertParamExists('getFundOperation', 'fundOperationId', fundOperationId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/{fund_operation_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"fund_operation_id"}}`, encodeURIComponent(String(fundOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List fund operations for an address.
         * @summary List fund operations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to list fund operations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundOperations: async (walletId: string, addressId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listFundOperations', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listFundOperations', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundApi - functional programming interface
 * @export
 */
export const FundApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FundApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new fund operation with an address.
         * @summary Create a new fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundOperationRequest} createFundOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFundOperation(walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundOperation(walletId, addressId, createFundOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundApi.createFundOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new fund operation with an address.
         * @summary Create a Fund Operation quote.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundQuoteRequest} createFundQuoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFundQuote(walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundQuote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundQuote(walletId, addressId, createFundQuoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundApi.createFundQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get fund operation.
         * @summary Get fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that created the fund operation.
         * @param {string} fundOperationId The ID of the fund operation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundOperation(walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundOperation(walletId, addressId, fundOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundApi.getFundOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List fund operations for an address.
         * @summary List fund operations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to list fund operations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFundOperations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundOperationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFundOperations(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundApi.listFundOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FundApi - factory interface
 * @export
 */
export const FundApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FundApiFp(configuration)
    return {
        /**
         * Create a new fund operation with an address.
         * @summary Create a new fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundOperationRequest} createFundOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundOperation(walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<FundOperation> {
            return localVarFp.createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new fund operation with an address.
         * @summary Create a Fund Operation quote.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundQuoteRequest} createFundQuoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundQuote(walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<FundQuote> {
            return localVarFp.createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get fund operation.
         * @summary Get fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that created the fund operation.
         * @param {string} fundOperationId The ID of the fund operation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundOperation(walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<FundOperation> {
            return localVarFp.getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List fund operations for an address.
         * @summary List fund operations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to list fund operations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundOperations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FundOperationList> {
            return localVarFp.listFundOperations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FundApi - interface
 * @export
 * @interface FundApi
 */
export interface FundApiInterface {
    /**
     * Create a new fund operation with an address.
     * @summary Create a new fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundOperationRequest} createFundOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApiInterface
     */
    createFundOperation(walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<FundOperation>;

    /**
     * Create a new fund operation with an address.
     * @summary Create a Fund Operation quote.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundQuoteRequest} createFundQuoteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApiInterface
     */
    createFundQuote(walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<FundQuote>;

    /**
     * Get fund operation.
     * @summary Get fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that created the fund operation.
     * @param {string} fundOperationId The ID of the fund operation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApiInterface
     */
    getFundOperation(walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<FundOperation>;

    /**
     * List fund operations for an address.
     * @summary List fund operations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to list fund operations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApiInterface
     */
    listFundOperations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FundOperationList>;

}

/**
 * FundApi - object-oriented interface
 * @export
 * @class FundApi
 * @extends {BaseAPI}
 */
export class FundApi extends BaseAPI implements FundApiInterface {
    /**
     * Create a new fund operation with an address.
     * @summary Create a new fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundOperationRequest} createFundOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public createFundOperation(walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig) {
        return FundApiFp(this.configuration).createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new fund operation with an address.
     * @summary Create a Fund Operation quote.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundQuoteRequest} createFundQuoteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public createFundQuote(walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig) {
        return FundApiFp(this.configuration).createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get fund operation.
     * @summary Get fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that created the fund operation.
     * @param {string} fundOperationId The ID of the fund operation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public getFundOperation(walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig) {
        return FundApiFp(this.configuration).getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List fund operations for an address.
     * @summary List fund operations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to list fund operations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    public listFundOperations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return FundApiFp(this.configuration).listFundOperations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MPCWalletStakeApi - axios parameter creator
 * @export
 */
export const MPCWalletStakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastStakingOperation: async (walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('broadcastStakingOperation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('broadcastStakingOperation', 'addressId', addressId)
            // verify required parameter 'stakingOperationId' is not null or undefined
            assertParamExists('broadcastStakingOperation', 'stakingOperationId', stakingOperationId)
            // verify required parameter 'broadcastStakingOperationRequest' is not null or undefined
            assertParamExists('broadcastStakingOperation', 'broadcastStakingOperationRequest', broadcastStakingOperationRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastStakingOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStakingOperation: async (walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createStakingOperation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createStakingOperation', 'addressId', addressId)
            // verify required parameter 'createStakingOperationRequest' is not null or undefined
            assertParamExists('createStakingOperation', 'createStakingOperationRequest', createStakingOperationRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStakingOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingOperation: async (walletId: string, addressId: string, stakingOperationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getStakingOperation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getStakingOperation', 'addressId', addressId)
            // verify required parameter 'stakingOperationId' is not null or undefined
            assertParamExists('getStakingOperation', 'stakingOperationId', stakingOperationId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MPCWalletStakeApi - functional programming interface
 * @export
 */
export const MPCWalletStakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MPCWalletStakeApiAxiosParamCreator(configuration)
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MPCWalletStakeApi.broadcastStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStakingOperation(walletId, addressId, createStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MPCWalletStakeApi.createStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingOperation(walletId, addressId, stakingOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MPCWalletStakeApi.getStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MPCWalletStakeApi - factory interface
 * @export
 */
export const MPCWalletStakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MPCWalletStakeApiFp(configuration)
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation> {
            return localVarFp.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation> {
            return localVarFp.createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation> {
            return localVarFp.getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MPCWalletStakeApi - interface
 * @export
 * @interface MPCWalletStakeApi
 */
export interface MPCWalletStakeApiInterface {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApiInterface
     */
    broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApiInterface
     */
    createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApiInterface
     */
    getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

}

/**
 * MPCWalletStakeApi - object-oriented interface
 * @export
 * @class MPCWalletStakeApi
 * @extends {BaseAPI}
 */
export class MPCWalletStakeApi extends BaseAPI implements MPCWalletStakeApiInterface {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    public broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig) {
        return MPCWalletStakeApiFp(this.configuration).broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    public createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig) {
        return MPCWalletStakeApiFp(this.configuration).createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    public getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig) {
        return MPCWalletStakeApiFp(this.configuration).getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NetworksApi - axios parameter creator
 * @export
 */
export const NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get network
         * @summary Get network by ID
         * @param {string} networkId The ID of the network to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetwork: async (networkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getNetwork', 'networkId', networkId)
            const localVarPath = `/v1/networks/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworksApi - functional programming interface
 * @export
 */
export const NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * Get network
         * @summary Get network by ID
         * @param {string} networkId The ID of the network to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetwork(networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetwork(networkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworksApi.getNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NetworksApi - factory interface
 * @export
 */
export const NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworksApiFp(configuration)
    return {
        /**
         * Get network
         * @summary Get network by ID
         * @param {string} networkId The ID of the network to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetwork(networkId: string, options?: RawAxiosRequestConfig): AxiosPromise<Network> {
            return localVarFp.getNetwork(networkId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworksApi - interface
 * @export
 * @interface NetworksApi
 */
export interface NetworksApiInterface {
    /**
     * Get network
     * @summary Get network by ID
     * @param {string} networkId The ID of the network to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApiInterface
     */
    getNetwork(networkId: string, options?: RawAxiosRequestConfig): AxiosPromise<Network>;

}

/**
 * NetworksApi - object-oriented interface
 * @export
 * @class NetworksApi
 * @extends {BaseAPI}
 */
export class NetworksApi extends BaseAPI implements NetworksApiInterface {
    /**
     * Get network
     * @summary Get network by ID
     * @param {string} networkId The ID of the network to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public getNetwork(networkId: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).getNetwork(networkId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OnchainIdentityApi - axios parameter creator
 * @export
 */
export const OnchainIdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Obtains onchain identity for an address on a specific network
         * @summary Obtains onchain identity for an address on a specific network
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the identity for
         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveIdentityByAddress: async (networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('resolveIdentityByAddress', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('resolveIdentityByAddress', 'addressId', addressId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/identity`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (roles) {
                localVarQueryParameter['roles'] = roles.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OnchainIdentityApi - functional programming interface
 * @export
 */
export const OnchainIdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OnchainIdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * Obtains onchain identity for an address on a specific network
         * @summary Obtains onchain identity for an address on a specific network
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the identity for
         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveIdentityByAddress(networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnchainNameList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OnchainIdentityApi.resolveIdentityByAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OnchainIdentityApi - factory interface
 * @export
 */
export const OnchainIdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OnchainIdentityApiFp(configuration)
    return {
        /**
         * Obtains onchain identity for an address on a specific network
         * @summary Obtains onchain identity for an address on a specific network
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the identity for
         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveIdentityByAddress(networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<OnchainNameList> {
            return localVarFp.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OnchainIdentityApi - interface
 * @export
 * @interface OnchainIdentityApi
 */
export interface OnchainIdentityApiInterface {
    /**
     * Obtains onchain identity for an address on a specific network
     * @summary Obtains onchain identity for an address on a specific network
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the identity for
     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainIdentityApiInterface
     */
    resolveIdentityByAddress(networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<OnchainNameList>;

}

/**
 * OnchainIdentityApi - object-oriented interface
 * @export
 * @class OnchainIdentityApi
 * @extends {BaseAPI}
 */
export class OnchainIdentityApi extends BaseAPI implements OnchainIdentityApiInterface {
    /**
     * Obtains onchain identity for an address on a specific network
     * @summary Obtains onchain identity for an address on a specific network
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the identity for
     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainIdentityApi
     */
    public resolveIdentityByAddress(networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return OnchainIdentityApiFp(this.configuration).resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ResolveIdentityByAddressRolesEnum = {
    Managed: 'managed',
    Owned: 'owned'
} as const;
export type ResolveIdentityByAddressRolesEnum = typeof ResolveIdentityByAddressRolesEnum[keyof typeof ResolveIdentityByAddressRolesEnum];


/**
 * ReputationApi - axios parameter creator
 * @export
 */
export const ReputationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the onchain reputation of an external address
         * @summary Get the onchain reputation of an external address
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} addressId The ID of the address to fetch the reputation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressReputation: async (networkId: string, addressId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getAddressReputation', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getAddressReputation', 'addressId', addressId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/reputation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReputationApi - functional programming interface
 * @export
 */
export const ReputationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReputationApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the onchain reputation of an external address
         * @summary Get the onchain reputation of an external address
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} addressId The ID of the address to fetch the reputation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressReputation(networkId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressReputation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressReputation(networkId, addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReputationApi.getAddressReputation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReputationApi - factory interface
 * @export
 */
export const ReputationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReputationApiFp(configuration)
    return {
        /**
         * Get the onchain reputation of an external address
         * @summary Get the onchain reputation of an external address
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} addressId The ID of the address to fetch the reputation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressReputation(networkId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressReputation> {
            return localVarFp.getAddressReputation(networkId, addressId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReputationApi - interface
 * @export
 * @interface ReputationApi
 */
export interface ReputationApiInterface {
    /**
     * Get the onchain reputation of an external address
     * @summary Get the onchain reputation of an external address
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} addressId The ID of the address to fetch the reputation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReputationApiInterface
     */
    getAddressReputation(networkId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressReputation>;

}

/**
 * ReputationApi - object-oriented interface
 * @export
 * @class ReputationApi
 * @extends {BaseAPI}
 */
export class ReputationApi extends BaseAPI implements ReputationApiInterface {
    /**
     * Get the onchain reputation of an external address
     * @summary Get the onchain reputation of an external address
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} addressId The ID of the address to fetch the reputation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReputationApi
     */
    public getAddressReputation(networkId: string, addressId: string, options?: RawAxiosRequestConfig) {
        return ReputationApiFp(this.configuration).getAddressReputation(networkId, addressId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerSignersApi - axios parameter creator
 * @export
 */
export const ServerSignersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServerSigner: async (createServerSignerRequest?: CreateServerSignerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/server_signers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServerSignerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSigner: async (serverSignerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverSignerId' is not null or undefined
            assertParamExists('getServerSigner', 'serverSignerId', serverSignerId)
            const localVarPath = `/v1/server_signers/{server_signer_id}`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listServerSignerEvents: async (serverSignerId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverSignerId' is not null or undefined
            assertParamExists('listServerSignerEvents', 'serverSignerId', serverSignerId)
            const localVarPath = `/v1/server_signers/{server_signer_id}/events`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerSigners: async (limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/server_signers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSeedEventResult: async (serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverSignerId' is not null or undefined
            assertParamExists('submitServerSignerSeedEventResult', 'serverSignerId', serverSignerId)
            const localVarPath = `/v1/server_signers/{server_signer_id}/seed_event_result`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(seedCreationEventResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSignatureEventResult: async (serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverSignerId' is not null or undefined
            assertParamExists('submitServerSignerSignatureEventResult', 'serverSignerId', serverSignerId)
            const localVarPath = `/v1/server_signers/{server_signer_id}/signature_event_result`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signatureCreationEventResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerSignersApi - functional programming interface
 * @export
 */
export const ServerSignersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerSignersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSigner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServerSigner(createServerSignerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.createServerSigner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSigner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSigner(serverSignerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.getServerSigner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSignerEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSignerEvents(serverSignerId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.listServerSignerEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSignerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSigners(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.listServerSigners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeedCreationEventResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.submitServerSignerSeedEventResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureCreationEventResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.submitServerSignerSignatureEventResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerSignersApi - factory interface
 * @export
 */
export const ServerSignersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerSignersApiFp(configuration)
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner> {
            return localVarFp.createServerSigner(createServerSignerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner> {
            return localVarFp.getServerSigner(serverSignerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerEventList> {
            return localVarFp.listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerList> {
            return localVarFp.listServerSigners(limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SeedCreationEventResult> {
            return localVarFp.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCreationEventResult> {
            return localVarFp.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerSignersApi - interface
 * @export
 * @interface ServerSignersApi
 */
export interface ServerSignersApiInterface {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner>;

    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner>;

    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerEventList>;

    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerList>;

    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SeedCreationEventResult>;

    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCreationEventResult>;

}

/**
 * ServerSignersApi - object-oriented interface
 * @export
 * @class ServerSignersApi
 * @extends {BaseAPI}
 */
export class ServerSignersApi extends BaseAPI implements ServerSignersApiInterface {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).createServerSigner(createServerSignerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).getServerSigner(serverSignerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).listServerSigners(limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SmartContractsApi - axios parameter creator
 * @export
 */
export const SmartContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Compile a smart contract
         * @summary Compile a smart contract
         * @param {CompileSmartContractRequest} compileSmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compileSmartContract: async (compileSmartContractRequest: CompileSmartContractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compileSmartContractRequest' is not null or undefined
            assertParamExists('compileSmartContract', 'compileSmartContractRequest', compileSmartContractRequest)
            const localVarPath = `/v1/smart_contracts/compile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(compileSmartContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new smart contract
         * @summary Create a new smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to deploy the smart contract from.
         * @param {CreateSmartContractRequest} createSmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSmartContract: async (walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createSmartContract', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createSmartContract', 'addressId', addressId)
            // verify required parameter 'createSmartContractRequest' is not null or undefined
            assertParamExists('createSmartContract', 'createSmartContractRequest', createSmartContractRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSmartContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploys a smart contract, by broadcasting the transaction to the network.
         * @summary Deploy a smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to broadcast the transaction from.
         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
         * @param {DeploySmartContractRequest} deploySmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploySmartContract: async (walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('deploySmartContract', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('deploySmartContract', 'addressId', addressId)
            // verify required parameter 'smartContractId' is not null or undefined
            assertParamExists('deploySmartContract', 'smartContractId', smartContractId)
            // verify required parameter 'deploySmartContractRequest' is not null or undefined
            assertParamExists('deploySmartContract', 'deploySmartContractRequest', deploySmartContractRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}/deploy`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"smart_contract_id"}}`, encodeURIComponent(String(smartContractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploySmartContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific smart contract deployed by address.
         * @summary Get a specific smart contract deployed by address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to fetch the smart contract for.
         * @param {string} smartContractId The UUID of the smart contract to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartContract: async (walletId: string, addressId: string, smartContractId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getSmartContract', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getSmartContract', 'addressId', addressId)
            // verify required parameter 'smartContractId' is not null or undefined
            assertParamExists('getSmartContract', 'smartContractId', smartContractId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"smart_contract_id"}}`, encodeURIComponent(String(smartContractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List smart contracts
         * @summary List smart contracts
         * @param {string} [page] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSmartContracts: async (page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/smart_contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a read operation on a smart contract without creating a transaction
         * @summary Read data from a smart contract
         * @param {string} networkId 
         * @param {string} contractAddress 
         * @param {ReadContractRequest} readContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract: async (networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('readContract', 'networkId', networkId)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('readContract', 'contractAddress', contractAddress)
            // verify required parameter 'readContractRequest' is not null or undefined
            assertParamExists('readContract', 'readContractRequest', readContractRequest)
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/read`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a smart contract
         * @summary Register a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {RegisterSmartContractRequest} [registerSmartContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSmartContract: async (networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('registerSmartContract', 'networkId', networkId)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('registerSmartContract', 'contractAddress', contractAddress)
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/register`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerSmartContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a smart contract
         * @summary Update a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {UpdateSmartContractRequest} [updateSmartContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSmartContract: async (networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('updateSmartContract', 'networkId', networkId)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('updateSmartContract', 'contractAddress', contractAddress)
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSmartContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmartContractsApi - functional programming interface
 * @export
 */
export const SmartContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * Compile a smart contract
         * @summary Compile a smart contract
         * @param {CompileSmartContractRequest} compileSmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compileSmartContract(compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompiledSmartContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compileSmartContract(compileSmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SmartContractsApi.compileSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new smart contract
         * @summary Create a new smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to deploy the smart contract from.
         * @param {CreateSmartContractRequest} createSmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSmartContract(walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSmartContract(walletId, addressId, createSmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SmartContractsApi.createSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deploys a smart contract, by broadcasting the transaction to the network.
         * @summary Deploy a smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to broadcast the transaction from.
         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
         * @param {DeploySmartContractRequest} deploySmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploySmartContract(walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SmartContractsApi.deploySmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific smart contract deployed by address.
         * @summary Get a specific smart contract deployed by address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to fetch the smart contract for.
         * @param {string} smartContractId The UUID of the smart contract to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSmartContract(walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmartContract(walletId, addressId, smartContractId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SmartContractsApi.getSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List smart contracts
         * @summary List smart contracts
         * @param {string} [page] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSmartContracts(page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContractList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSmartContracts(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SmartContractsApi.listSmartContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform a read operation on a smart contract without creating a transaction
         * @summary Read data from a smart contract
         * @param {string} networkId 
         * @param {string} contractAddress 
         * @param {ReadContractRequest} readContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readContract(networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolidityValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readContract(networkId, contractAddress, readContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SmartContractsApi.readContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a smart contract
         * @summary Register a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {RegisterSmartContractRequest} [registerSmartContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSmartContract(networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SmartContractsApi.registerSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a smart contract
         * @summary Update a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {UpdateSmartContractRequest} [updateSmartContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSmartContract(networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SmartContractsApi.updateSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SmartContractsApi - factory interface
 * @export
 */
export const SmartContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SmartContractsApiFp(configuration)
    return {
        /**
         * Compile a smart contract
         * @summary Compile a smart contract
         * @param {CompileSmartContractRequest} compileSmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compileSmartContract(compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<CompiledSmartContract> {
            return localVarFp.compileSmartContract(compileSmartContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new smart contract
         * @summary Create a new smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to deploy the smart contract from.
         * @param {CreateSmartContractRequest} createSmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSmartContract(walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract> {
            return localVarFp.createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploys a smart contract, by broadcasting the transaction to the network.
         * @summary Deploy a smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to broadcast the transaction from.
         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
         * @param {DeploySmartContractRequest} deploySmartContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploySmartContract(walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract> {
            return localVarFp.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific smart contract deployed by address.
         * @summary Get a specific smart contract deployed by address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to fetch the smart contract for.
         * @param {string} smartContractId The UUID of the smart contract to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartContract(walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract> {
            return localVarFp.getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(axios, basePath));
        },
        /**
         * List smart contracts
         * @summary List smart contracts
         * @param {string} [page] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSmartContracts(page?: string, options?: RawAxiosRequestConfig): AxiosPromise<SmartContractList> {
            return localVarFp.listSmartContracts(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a read operation on a smart contract without creating a transaction
         * @summary Read data from a smart contract
         * @param {string} networkId 
         * @param {string} contractAddress 
         * @param {ReadContractRequest} readContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract(networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SolidityValue> {
            return localVarFp.readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a smart contract
         * @summary Register a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {RegisterSmartContractRequest} [registerSmartContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSmartContract(networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract> {
            return localVarFp.registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a smart contract
         * @summary Update a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {UpdateSmartContractRequest} [updateSmartContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSmartContract(networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract> {
            return localVarFp.updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartContractsApi - interface
 * @export
 * @interface SmartContractsApi
 */
export interface SmartContractsApiInterface {
    /**
     * Compile a smart contract
     * @summary Compile a smart contract
     * @param {CompileSmartContractRequest} compileSmartContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    compileSmartContract(compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<CompiledSmartContract>;

    /**
     * Create a new smart contract
     * @summary Create a new smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to deploy the smart contract from.
     * @param {CreateSmartContractRequest} createSmartContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    createSmartContract(walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;

    /**
     * Deploys a smart contract, by broadcasting the transaction to the network.
     * @summary Deploy a smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to broadcast the transaction from.
     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
     * @param {DeploySmartContractRequest} deploySmartContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    deploySmartContract(walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;

    /**
     * Get a specific smart contract deployed by address.
     * @summary Get a specific smart contract deployed by address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to fetch the smart contract for.
     * @param {string} smartContractId The UUID of the smart contract to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    getSmartContract(walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;

    /**
     * List smart contracts
     * @summary List smart contracts
     * @param {string} [page] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    listSmartContracts(page?: string, options?: RawAxiosRequestConfig): AxiosPromise<SmartContractList>;

    /**
     * Perform a read operation on a smart contract without creating a transaction
     * @summary Read data from a smart contract
     * @param {string} networkId 
     * @param {string} contractAddress 
     * @param {ReadContractRequest} readContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    readContract(networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SolidityValue>;

    /**
     * Register a smart contract
     * @summary Register a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {RegisterSmartContractRequest} [registerSmartContractRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    registerSmartContract(networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;

    /**
     * Update a smart contract
     * @summary Update a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {UpdateSmartContractRequest} [updateSmartContractRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    updateSmartContract(networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;

}

/**
 * SmartContractsApi - object-oriented interface
 * @export
 * @class SmartContractsApi
 * @extends {BaseAPI}
 */
export class SmartContractsApi extends BaseAPI implements SmartContractsApiInterface {
    /**
     * Compile a smart contract
     * @summary Compile a smart contract
     * @param {CompileSmartContractRequest} compileSmartContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    public compileSmartContract(compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig) {
        return SmartContractsApiFp(this.configuration).compileSmartContract(compileSmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new smart contract
     * @summary Create a new smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to deploy the smart contract from.
     * @param {CreateSmartContractRequest} createSmartContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    public createSmartContract(walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig) {
        return SmartContractsApiFp(this.configuration).createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploys a smart contract, by broadcasting the transaction to the network.
     * @summary Deploy a smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to broadcast the transaction from.
     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
     * @param {DeploySmartContractRequest} deploySmartContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    public deploySmartContract(walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig) {
        return SmartContractsApiFp(this.configuration).deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific smart contract deployed by address.
     * @summary Get a specific smart contract deployed by address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to fetch the smart contract for.
     * @param {string} smartContractId The UUID of the smart contract to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    public getSmartContract(walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig) {
        return SmartContractsApiFp(this.configuration).getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List smart contracts
     * @summary List smart contracts
     * @param {string} [page] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    public listSmartContracts(page?: string, options?: RawAxiosRequestConfig) {
        return SmartContractsApiFp(this.configuration).listSmartContracts(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a read operation on a smart contract without creating a transaction
     * @summary Read data from a smart contract
     * @param {string} networkId 
     * @param {string} contractAddress 
     * @param {ReadContractRequest} readContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    public readContract(networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig) {
        return SmartContractsApiFp(this.configuration).readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a smart contract
     * @summary Register a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {RegisterSmartContractRequest} [registerSmartContractRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    public registerSmartContract(networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig) {
        return SmartContractsApiFp(this.configuration).registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a smart contract
     * @summary Update a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {UpdateSmartContractRequest} [updateSmartContractRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    public updateSmartContract(networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig) {
        return SmartContractsApiFp(this.configuration).updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StakeApi - axios parameter creator
 * @export
 */
export const StakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildStakingOperation: async (buildStakingOperationRequest: BuildStakingOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'buildStakingOperationRequest' is not null or undefined
            assertParamExists('buildStakingOperation', 'buildStakingOperationRequest', buildStakingOperationRequest)
            const localVarPath = `/v1/stake/build`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildStakingOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch historical staking balances for given address.
         * @summary Fetch historical staking balances
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
         * @param {string} startTime The start time of this historical staking balance period.
         * @param {string} endTime The end time of this historical staking balance period.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchHistoricalStakingBalances: async (networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('fetchHistoricalStakingBalances', 'networkId', networkId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('fetchHistoricalStakingBalances', 'assetId', assetId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('fetchHistoricalStakingBalances', 'addressId', addressId)
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('fetchHistoricalStakingBalances', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('fetchHistoricalStakingBalances', 'endTime', endTime)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/stake/balances`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest 
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStakingRewards: async (fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fetchStakingRewardsRequest' is not null or undefined
            assertParamExists('fetchStakingRewards', 'fetchStakingRewardsRequest', fetchStakingRewardsRequest)
            const localVarPath = `/v1/stake/rewards/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fetchStakingRewardsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalStakingOperation: async (networkId: string, addressId: string, stakingOperationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getExternalStakingOperation', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getExternalStakingOperation', 'addressId', addressId)
            // verify required parameter 'stakingOperationId' is not null or undefined
            assertParamExists('getExternalStakingOperation', 'stakingOperationId', stakingOperationId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingContext: async (getStakingContextRequest: GetStakingContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getStakingContextRequest' is not null or undefined
            assertParamExists('getStakingContext', 'getStakingContextRequest', getStakingContextRequest)
            const localVarPath = `/v1/stake/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStakingContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator: async (networkId: string, assetId: string, validatorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getValidator', 'networkId', networkId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getValidator', 'assetId', assetId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('getValidator', 'validatorId', validatorId)
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators/{validator_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {ValidatorStatus} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValidators: async (networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listValidators', 'networkId', networkId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('listValidators', 'assetId', assetId)
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StakeApi - functional programming interface
 * @export
 */
export const StakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StakeApiAxiosParamCreator(configuration)
    return {
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildStakingOperation(buildStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.buildStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch historical staking balances for given address.
         * @summary Fetch historical staking balances
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
         * @param {string} startTime The start time of this historical staking balance period.
         * @param {string} endTime The end time of this historical staking balance period.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchHistoricalStakingBalances(networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchHistoricalStakingBalances200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.fetchHistoricalStakingBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest 
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchStakingRewards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.fetchStakingRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalStakingOperation(networkId, addressId, stakingOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.getExternalStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingContext(getStakingContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.getStakingContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(networkId, assetId, validatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.getValidator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {ValidatorStatus} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listValidators(networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listValidators(networkId, assetId, status, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.listValidators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StakeApi - factory interface
 * @export
 */
export const StakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StakeApiFp(configuration)
    return {
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation> {
            return localVarFp.buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch historical staking balances for given address.
         * @summary Fetch historical staking balances
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
         * @param {string} startTime The start time of this historical staking balance period.
         * @param {string} endTime The end time of this historical staking balance period.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchHistoricalStakingBalances(networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchHistoricalStakingBalances200Response> {
            return localVarFp.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest 
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchStakingRewards200Response> {
            return localVarFp.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation> {
            return localVarFp.getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingContext> {
            return localVarFp.getStakingContext(getStakingContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Validator> {
            return localVarFp.getValidator(networkId, assetId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {ValidatorStatus} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValidators(networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ValidatorList> {
            return localVarFp.listValidators(networkId, assetId, status, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StakeApi - interface
 * @export
 * @interface StakeApi
 */
export interface StakeApiInterface {
    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

    /**
     * Fetch historical staking balances for given address.
     * @summary Fetch historical staking balances
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
     * @param {string} startTime The start time of this historical staking balance period.
     * @param {string} endTime The end time of this historical staking balance period.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    fetchHistoricalStakingBalances(networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchHistoricalStakingBalances200Response>;

    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest 
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchStakingRewards200Response>;

    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingContext>;

    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Validator>;

    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {ValidatorStatus} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    listValidators(networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ValidatorList>;

}

/**
 * StakeApi - object-oriented interface
 * @export
 * @class StakeApi
 * @extends {BaseAPI}
 */
export class StakeApi extends BaseAPI implements StakeApiInterface {
    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch historical staking balances for given address.
     * @summary Fetch historical staking balances
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
     * @param {string} startTime The start time of this historical staking balance period.
     * @param {string} endTime The end time of this historical staking balance period.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public fetchHistoricalStakingBalances(networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest 
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).getStakingContext(getStakingContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).getValidator(networkId, assetId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {ValidatorStatus} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public listValidators(networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).listValidators(networkId, assetId, status, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TradesApi - axios parameter creator
 * @export
 */
export const TradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTrade: async (walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('broadcastTrade', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('broadcastTrade', 'addressId', addressId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('broadcastTrade', 'tradeId', tradeId)
            // verify required parameter 'broadcastTradeRequest' is not null or undefined
            assertParamExists('broadcastTrade', 'broadcastTradeRequest', broadcastTradeRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade: async (walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createTrade', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createTrade', 'addressId', addressId)
            // verify required parameter 'createTradeRequest' is not null or undefined
            assertParamExists('createTrade', 'createTradeRequest', createTradeRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (walletId: string, addressId: string, tradeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getTrade', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getTrade', 'addressId', addressId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('getTrade', 'tradeId', tradeId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (walletId: string, addressId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listTrades', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listTrades', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradesApi - functional programming interface
 * @export
 */
export const TradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradesApiAxiosParamCreator(configuration)
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradesApi.broadcastTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrade(walletId, addressId, createTradeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradesApi.createTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(walletId, addressId, tradeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradesApi.getTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradesApi.listTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradesApi - factory interface
 * @export
 */
export const TradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradesApiFp(configuration)
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade> {
            return localVarFp.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade> {
            return localVarFp.createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Trade> {
            return localVarFp.getTrade(walletId, addressId, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TradeList> {
            return localVarFp.listTrades(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradesApi - interface
 * @export
 * @interface TradesApi
 */
export interface TradesApiInterface {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;

    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;

    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;

    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TradeList>;

}

/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
export class TradesApi extends BaseAPI implements TradesApiInterface {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig) {
        return TradesApiFp(this.configuration).broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig) {
        return TradesApiFp(this.configuration).createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig) {
        return TradesApiFp(this.configuration).getTrade(walletId, addressId, tradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return TradesApiFp(this.configuration).listTrades(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionHistoryApi - axios parameter creator
 * @export
 */
export const TransactionHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all transactions that interact with the address.
         * @summary List transactions for an address.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the transactions for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressTransactions: async (networkId: string, addressId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listAddressTransactions', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listAddressTransactions', 'addressId', addressId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transactions`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionHistoryApi - functional programming interface
 * @export
 */
export const TransactionHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * List all transactions that interact with the address.
         * @summary List transactions for an address.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the transactions for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressTransactions(networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTransactionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressTransactions(networkId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionHistoryApi.listAddressTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionHistoryApi - factory interface
 * @export
 */
export const TransactionHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionHistoryApiFp(configuration)
    return {
        /**
         * List all transactions that interact with the address.
         * @summary List transactions for an address.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the transactions for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressTransactions(networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressTransactionList> {
            return localVarFp.listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionHistoryApi - interface
 * @export
 * @interface TransactionHistoryApi
 */
export interface TransactionHistoryApiInterface {
    /**
     * List all transactions that interact with the address.
     * @summary List transactions for an address.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the transactions for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionHistoryApiInterface
     */
    listAddressTransactions(networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressTransactionList>;

}

/**
 * TransactionHistoryApi - object-oriented interface
 * @export
 * @class TransactionHistoryApi
 * @extends {BaseAPI}
 */
export class TransactionHistoryApi extends BaseAPI implements TransactionHistoryApiInterface {
    /**
     * List all transactions that interact with the address.
     * @summary List transactions for an address.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the transactions for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionHistoryApi
     */
    public listAddressTransactions(networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return TransactionHistoryApiFp(this.configuration).listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTransfer: async (walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('broadcastTransfer', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('broadcastTransfer', 'addressId', addressId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('broadcastTransfer', 'transferId', transferId)
            // verify required parameter 'broadcastTransferRequest' is not null or undefined
            assertParamExists('broadcastTransfer', 'broadcastTransferRequest', broadcastTransferRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createTransfer', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createTransfer', 'addressId', addressId)
            // verify required parameter 'createTransferRequest' is not null or undefined
            assertParamExists('createTransfer', 'createTransferRequest', createTransferRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (walletId: string, addressId: string, transferId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getTransfer', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getTransfer', 'addressId', addressId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('getTransfer', 'transferId', transferId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers: async (walletId: string, addressId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listTransfers', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listTransfers', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.broadcastTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(walletId, addressId, createTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.createTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(walletId, addressId, transferId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.getTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.listTransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer> {
            return localVarFp.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer> {
            return localVarFp.createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer> {
            return localVarFp.getTransfer(walletId, addressId, transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TransferList> {
            return localVarFp.listTransfers(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - interface
 * @export
 * @interface TransfersApi
 */
export interface TransfersApiInterface {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TransferList>;

}

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI implements TransfersApiInterface {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getTransfer(walletId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).listTransfers(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletsApi - axios parameter creator
 * @export
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet: async (createWalletRequest?: CreateWalletRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet: async (walletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getWallet', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance: async (walletId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getWalletBalance', 'walletId', walletId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getWalletBalance', 'assetId', assetId)
            const localVarPath = `/v1/wallets/{wallet_id}/balances/{asset_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWalletBalances: async (walletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listWalletBalances', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}/balances`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets: async (limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletsApi - functional programming interface
 * @export
 */
export const WalletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(createWalletRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.createWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallet(walletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(walletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.getWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(walletId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletBalances(walletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.listWalletBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.listWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletsApi - factory interface
 * @export
 */
export const WalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletsApiFp(configuration)
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<Wallet> {
            return localVarFp.createWallet(createWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<Wallet> {
            return localVarFp.getWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance> {
            return localVarFp.getWalletBalance(walletId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList> {
            return localVarFp.listWalletBalances(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletList> {
            return localVarFp.listWallets(limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletsApi - interface
 * @export
 * @interface WalletsApi
 */
export interface WalletsApiInterface {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<Wallet>;

    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    getWallet(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<Wallet>;

    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;

    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;

    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletList>;

}

/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI implements WalletsApiInterface {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).createWallet(createWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public getWallet(walletId: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).getWalletBalance(walletId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public listWalletBalances(walletId: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).listWalletBalances(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).listWallets(limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook scoped to a wallet
         * @summary Create a new webhook scoped to a wallet
         * @param {string} walletId The ID of the wallet to create the webhook for.
         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWebhook: async (walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createWalletWebhook', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}/webhooks`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWalletWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookRequest?: CreateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)

            // authentication session required
            await setApiKeyToObject(localVarHeaderParameter, "Jwt", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook scoped to a wallet
         * @summary Create a new webhook scoped to a wallet
         * @param {string} walletId The ID of the wallet to create the webhook for.
         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWebhook(walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletWebhook(walletId, createWalletWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.createWalletWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook scoped to a wallet
         * @summary Create a new webhook scoped to a wallet
         * @param {string} walletId The ID of the wallet to create the webhook for.
         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWebhook(walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookList> {
            return localVarFp.listWebhooks(limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - interface
 * @export
 * @interface WebhooksApi
 */
export interface WebhooksApiInterface {
    /**
     * Create a new webhook scoped to a wallet
     * @summary Create a new webhook scoped to a wallet
     * @param {string} walletId The ID of the wallet to create the webhook for.
     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    createWalletWebhook(walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;

    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;

    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookList>;

    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;

}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI implements WebhooksApiInterface {
    /**
     * Create a new webhook scoped to a wallet
     * @summary Create a new webhook scoped to a wallet
     * @param {string} walletId The ID of the wallet to create the webhook for.
     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWalletWebhook(walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).listWebhooks(limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



