/* tslint:disable */
/* eslint-disable */
/**
 * Coinbase Platform API
 * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.
 *
 * The version of the OpenAPI document: 0.0.1-alpha
 * Contact: yuga.cohler@coinbase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * The ID of the wallet that owns the address
     * @type {string}
     * @memberof Address
     */
    'wallet_id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Address
     */
    'network_id': string;
    /**
     * The public key from which the address is derived.
     * @type {string}
     * @memberof Address
     */
    'public_key': string;
    /**
     * The onchain address derived on the server-side.
     * @type {string}
     * @memberof Address
     */
    'address_id': string;
}
/**
 *
 * @export
 * @interface AddressBalanceList
 */
export interface AddressBalanceList {
    /**
     *
     * @type {Array<Balance>}
     * @memberof AddressBalanceList
     */
    'data': Array<Balance>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressBalanceList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressBalanceList
     */
    'next_page': string;
    /**
     * The total number of balances for the wallet.
     * @type {number}
     * @memberof AddressBalanceList
     */
    'total_count': number;
}
/**
 *
 * @export
 * @interface AddressHistoricalBalanceList
 */
export interface AddressHistoricalBalanceList {
    /**
     *
     * @type {Array<HistoricalBalance>}
     * @memberof AddressHistoricalBalanceList
     */
    'data': Array<HistoricalBalance>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressHistoricalBalanceList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressHistoricalBalanceList
     */
    'next_page': string;
}
/**
 *
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     *
     * @type {Array<Address>}
     * @memberof AddressList
     */
    'data': Array<Address>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressList
     */
    'next_page': string;
    /**
     * The total number of addresses for the wallet.
     * @type {number}
     * @memberof AddressList
     */
    'total_count': number;
}
/**
 * An asset onchain scoped to a particular network, e.g. ETH on base-sepolia, or the USDC ERC20 Token on ethereum-mainnet.
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Asset
     */
    'network_id': string;
    /**
     * The ID for the asset on the network
     * @type {string}
     * @memberof Asset
     */
    'asset_id': string;
    /**
     * The number of decimals the asset supports. This is used to convert from atomic units to base units.
     * @type {number}
     * @memberof Asset
     */
    'decimals'?: number;
    /**
     * The optional contract address for the asset. This will be specified for smart contract-based assets, for example ERC20s.
     * @type {string}
     * @memberof Asset
     */
    'contract_address'?: string;
}
/**
 * The balance of an asset onchain
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof Balance
     */
    'amount': string;
    /**
     *
     * @type {Asset}
     * @memberof Balance
     */
    'asset': Asset;
}
/**
 *
 * @export
 * @interface BroadcastStakingOperationRequest
 */
export interface BroadcastStakingOperationRequest {
    /**
     * The hex-encoded signed payload of the staking operation.
     * @type {string}
     * @memberof BroadcastStakingOperationRequest
     */
    'signed_payload': string;
    /**
     * The index in the transaction array of the staking operation.
     * @type {number}
     * @memberof BroadcastStakingOperationRequest
     */
    'transaction_index': number;
}
/**
 *
 * @export
 * @interface BroadcastTradeRequest
 */
export interface BroadcastTradeRequest {
    /**
     * The hex-encoded signed payload of the trade
     * @type {string}
     * @memberof BroadcastTradeRequest
     */
    'signed_payload': string;
    /**
     * The hex-encoded signed payload of the approval transaction
     * @type {string}
     * @memberof BroadcastTradeRequest
     */
    'approve_transaction_signed_payload'?: string;
}
/**
 *
 * @export
 * @interface BroadcastTransferRequest
 */
export interface BroadcastTransferRequest {
    /**
     * The hex-encoded signed payload of the transfer
     * @type {string}
     * @memberof BroadcastTransferRequest
     */
    'signed_payload': string;
}
/**
 *
 * @export
 * @interface BuildStakingOperationRequest
 */
export interface BuildStakingOperationRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'asset_id': string;
    /**
     * The onchain address from which the staking transaction originates and is responsible for signing the transaction.
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'address_id': string;
    /**
     * The type of staking operation
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'action': string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof BuildStakingOperationRequest
     */
    'options': { [key: string]: string; };
}
/**
 * Represents a single decoded event emitted by a smart contract
 * @export
 * @interface ContractEvent
 */
export interface ContractEvent {
    /**
     * The name of the blockchain network
     * @type {string}
     * @memberof ContractEvent
     */
    'network_name'?: string;
    /**
     * The name of the blockchain project or protocol
     * @type {string}
     * @memberof ContractEvent
     */
    'protocol_name'?: string;
    /**
     * The name of the specific contract within the project
     * @type {string}
     * @memberof ContractEvent
     */
    'contract_name'?: string;
    /**
     * The name of the event emitted by the contract
     * @type {string}
     * @memberof ContractEvent
     */
    'event_name'?: string;
    /**
     * The signature of the event, including parameter types
     * @type {string}
     * @memberof ContractEvent
     */
    'sig'?: string;
    /**
     * The first four bytes of the Keccak hash of the event signature
     * @type {string}
     * @memberof ContractEvent
     */
    'fourBytes'?: string;
    /**
     * The EVM address of the smart contract
     * @type {string}
     * @memberof ContractEvent
     */
    'contract_address'?: string;
    /**
     * The timestamp of the block in which the event was emitted
     * @type {string}
     * @memberof ContractEvent
     */
    'block_time'?: string;
    /**
     * The block number in which the event was emitted
     * @type {number}
     * @memberof ContractEvent
     */
    'block_height'?: number;
    /**
     * The transaction hash in which the event was emitted
     * @type {string}
     * @memberof ContractEvent
     */
    'tx_hash'?: string;
    /**
     * The index of the transaction within the block
     * @type {number}
     * @memberof ContractEvent
     */
    'tx_index'?: number;
    /**
     * The index of the event within the transaction
     * @type {number}
     * @memberof ContractEvent
     */
    'event_index'?: number;
    /**
     * The event data in a stringified format
     * @type {string}
     * @memberof ContractEvent
     */
    'data'?: string;
}
/**
 * A list of contract events with pagination information
 * @export
 * @interface ContractEventList
 */
export interface ContractEventList {
    /**
     * An array of ContractEvent objects
     * @type {Array<ContractEvent>}
     * @memberof ContractEventList
     */
    'data': Array<ContractEvent>;
    /**
     * The page token to be used to fetch the next page
     * @type {string}
     * @memberof ContractEventList
     */
    'next_page': string;
    /**
     * True if this list has another page of items after this one that can be fetched
     * @type {boolean}
     * @memberof ContractEventList
     */
    'has_more': boolean;
}
/**
 *
 * @export
 * @interface CreateAddressRequest
 */
export interface CreateAddressRequest {
    /**
     * The public key from which the address will be derived.
     * @type {string}
     * @memberof CreateAddressRequest
     */
    'public_key'?: string;
    /**
     * An attestation signed by the private key that is associated with the wallet. The attestation will be a hex-encoded signature of a json payload with fields `wallet_id` and `public_key`, signed by the private key associated with the public_key set in the request.
     * @type {string}
     * @memberof CreateAddressRequest
     */
    'attestation'?: string;
}
/**
 *
 * @export
 * @interface CreateServerSignerRequest
 */
export interface CreateServerSignerRequest {
    /**
     * The ID of the server signer for the 1 of 1 server signer.
     * @type {string}
     * @memberof CreateServerSignerRequest
     */
    'server_signer_id'?: string;
    /**
     * The enrollment data of the server signer. This will be the base64 encoded server-signer-id for the 1 of 1 server signer.
     * @type {string}
     * @memberof CreateServerSignerRequest
     */
    'enrollment_data': string;
    /**
     * Whether the Server-Signer uses MPC.
     * @type {boolean}
     * @memberof CreateServerSignerRequest
     */
    'is_mpc': boolean;
}
/**
 *
 * @export
 * @interface CreateStakingOperationRequest
 */
export interface CreateStakingOperationRequest {
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'asset_id': string;
    /**
     * The type of staking operation.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'action': string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreateStakingOperationRequest
     */
    'options': { [key: string]: string; };
}
/**
 *
 * @export
 * @interface CreateTradeRequest
 */
export interface CreateTradeRequest {
    /**
     * The amount to trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'amount': string;
    /**
     * The ID of the asset to trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'from_asset_id': string;
    /**
     * The ID of the asset to receive from the trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'to_asset_id': string;
}
/**
 *
 * @export
 * @interface CreateTransferRequest
 */
export interface CreateTransferRequest {
    /**
     * The amount to transfer
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'amount': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'network_id': string;
    /**
     * The ID of the asset to transfer
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'asset_id': string;
    /**
     * The destination address
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'destination': string;
}
/**
 *
 * @export
 * @interface CreateWalletRequest
 */
export interface CreateWalletRequest {
    /**
     *
     * @type {CreateWalletRequestWallet}
     * @memberof CreateWalletRequest
     */
    'wallet': CreateWalletRequestWallet;
}
/**
 * Parameters for configuring a wallet
 * @export
 * @interface CreateWalletRequestWallet
 */
export interface CreateWalletRequestWallet {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateWalletRequestWallet
     */
    'network_id': string;
    /**
     * Whether the wallet should use the project\'s server signer or if the addresses in the wallets will belong to a private key the developer manages. Defaults to false.
     * @type {boolean}
     * @memberof CreateWalletRequestWallet
     */
    'use_server_signer'?: boolean;
}
/**
 *
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'network_id': string;
    /**
     *
     * @type {WebhookEventType}
     * @memberof CreateWebhookRequest
     */
    'event_type'?: WebhookEventType;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof CreateWebhookRequest
     */
    'event_filters'?: Array<WebhookEventFilter>;
    /**
     * The URL to which the notifications will be sent
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'notification_uri': string;
}


/**
 * An Ethereum validator.
 * @export
 * @interface EthereumValidatorMetadata
 */
export interface EthereumValidatorMetadata {
    /**
     * The index of the validator in the validator set.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'index': string;
    /**
     * The public key of the validator.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'public_key': string;
    /**
     * The address to which the validator\'s rewards are sent.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'withdrawl_address': string;
    /**
     * Whether the validator has been slashed.
     * @type {boolean}
     * @memberof EthereumValidatorMetadata
     */
    'slashed': boolean;
    /**
     * The epoch at which the validator was activated.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'activationEpoch': string;
    /**
     * The epoch at which the validator exited.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'exitEpoch': string;
    /**
     * The epoch at which the validator can withdraw.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'withdrawableEpoch': string;
    /**
     *
     * @type {Balance}
     * @memberof EthereumValidatorMetadata
     */
    'balance': Balance;
    /**
     *
     * @type {Balance}
     * @memberof EthereumValidatorMetadata
     */
    'effective_balance': Balance;
}
/**
 * The faucet transaction
 * @export
 * @interface FaucetTransaction
 */
export interface FaucetTransaction {
    /**
     * The transaction hash of the transaction the faucet created.
     * @type {string}
     * @memberof FaucetTransaction
     */
    'transaction_hash': string;
    /**
     * Link to the transaction on the blockchain explorer.
     * @type {string}
     * @memberof FaucetTransaction
     */
    'transaction_link': string;
}
/**
 * Features that can be enabled for a wallet
 * @export
 * @enum {string}
 */

export const Feature = {
    Transfer: 'transfer',
    Trade: 'trade',
    Faucet: 'faucet',
    ServerSigner: 'server_signer'
} as const;

export type Feature = typeof Feature[keyof typeof Feature];


/**
 *
 * @export
 * @interface FetchStakingRewards200Response
 */
export interface FetchStakingRewards200Response {
    /**
     *
     * @type {Array<StakingReward>}
     * @memberof FetchStakingRewards200Response
     */
    'data': Array<StakingReward>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof FetchStakingRewards200Response
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof FetchStakingRewards200Response
     */
    'next_page': string;
}
/**
 *
 * @export
 * @interface FetchStakingRewardsRequest
 */
export interface FetchStakingRewardsRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'network_id': string;
    /**
     * The ID of the asset for which the staking rewards are being fetched
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'asset_id': string;
    /**
     * The onchain addresses for which the staking rewards are being fetched
     * @type {Array<string>}
     * @memberof FetchStakingRewardsRequest
     */
    'address_ids': Array<string>;
    /**
     * The start time of this reward period
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'start_time': string;
    /**
     * The end time of this reward period
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'end_time': string;
    /**
     *
     * @type {StakingRewardFormat}
     * @memberof FetchStakingRewardsRequest
     */
    'format': StakingRewardFormat;
}


/**
 *
 * @export
 * @interface GetStakingContextRequest
 */
export interface GetStakingContextRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'asset_id': string;
    /**
     * The onchain address for which the staking context is being fetched
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'address_id': string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof GetStakingContextRequest
     */
    'options': { [key: string]: string; };
}
/**
 * The balance of an asset onchain at a particular block
 * @export
 * @interface HistoricalBalance
 */
export interface HistoricalBalance {
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof HistoricalBalance
     */
    'amount': string;
    /**
     * The hash of the block at which the balance was recorded
     * @type {string}
     * @memberof HistoricalBalance
     */
    'block_hash': string;
    /**
     * The block height at which the balance was recorded
     * @type {string}
     * @memberof HistoricalBalance
     */
    'block_height': string;
    /**
     *
     * @type {Asset}
     * @memberof HistoricalBalance
     */
    'asset': Asset;
}
/**
 * An error response from the Coinbase Developer Platform API
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A short string representing the reported error. Can be use to handle errors programmatically.
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * A human-readable message providing more details about the error.
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * The native eth staking context.
 * @export
 * @interface NativeEthStakingContext
 */
export interface NativeEthStakingContext {
    /**
     *
     * @type {Balance}
     * @memberof NativeEthStakingContext
     */
    'stakeable_balance': Balance;
    /**
     *
     * @type {Balance}
     * @memberof NativeEthStakingContext
     */
    'unstakeable_balance': Balance;
    /**
     *
     * @type {Balance}
     * @memberof NativeEthStakingContext
     */
    'claimable_balance': Balance;
}
/**
 * The partial eth staking context.
 * @export
 * @interface PartialEthStakingContext
 */
export interface PartialEthStakingContext {
    /**
     *
     * @type {Balance}
     * @memberof PartialEthStakingContext
     */
    'stakeable_balance': Balance;
    /**
     *
     * @type {Balance}
     * @memberof PartialEthStakingContext
     */
    'unstakeable_balance': Balance;
    /**
     *
     * @type {Balance}
     * @memberof PartialEthStakingContext
     */
    'claimable_balance': Balance;
}
/**
 * An event representing a seed creation.
 * @export
 * @interface SeedCreationEvent
 */
export interface SeedCreationEvent {
    /**
     * The ID of the wallet that the server-signer should create the seed for
     * @type {string}
     * @memberof SeedCreationEvent
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SeedCreationEvent
     */
    'wallet_user_id': string;
}
/**
 * The result to a SeedCreationEvent.
 * @export
 * @interface SeedCreationEventResult
 */
export interface SeedCreationEventResult {
    /**
     * The ID of the wallet that the seed was created for
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'wallet_user_id': string;
    /**
     * The extended public key for the first master key derived from seed.
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'extended_public_key': string;
    /**
     * The ID of the seed in Server-Signer used to generate the extended public key.
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'seed_id': string;
}
/**
 * A Server-Signer assigned to sign transactions in a wallet.
 * @export
 * @interface ServerSigner
 */
export interface ServerSigner {
    /**
     * The ID of the server-signer
     * @type {string}
     * @memberof ServerSigner
     */
    'server_signer_id': string;
    /**
     * The IDs of the wallets that the server-signer can sign for
     * @type {Array<string>}
     * @memberof ServerSigner
     */
    'wallets'?: Array<string>;
    /**
     * Whether the Server-Signer uses MPC.
     * @type {boolean}
     * @memberof ServerSigner
     */
    'is_mpc': boolean;
}
/**
 * An event that is waiting to be processed by a Server-Signer.
 * @export
 * @interface ServerSignerEvent
 */
export interface ServerSignerEvent {
    /**
     * The ID of the server-signer that the event is for
     * @type {string}
     * @memberof ServerSignerEvent
     */
    'server_signer_id': string;
    /**
     *
     * @type {ServerSignerEventEvent}
     * @memberof ServerSignerEvent
     */
    'event': ServerSignerEventEvent;
}
/**
 * @type ServerSignerEventEvent
 * @export
 */
export type ServerSignerEventEvent = SeedCreationEvent | SignatureCreationEvent;

/**
 *
 * @export
 * @interface ServerSignerEventList
 */
export interface ServerSignerEventList {
    /**
     *
     * @type {Array<ServerSignerEvent>}
     * @memberof ServerSignerEventList
     */
    'data': Array<ServerSignerEvent>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ServerSignerEventList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ServerSignerEventList
     */
    'next_page': string;
    /**
     * The total number of events for the server signer.
     * @type {number}
     * @memberof ServerSignerEventList
     */
    'total_count': number;
}
/**
 *
 * @export
 * @interface ServerSignerList
 */
export interface ServerSignerList {
    /**
     *
     * @type {Array<ServerSigner>}
     * @memberof ServerSignerList
     */
    'data': Array<ServerSigner>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ServerSignerList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ServerSignerList
     */
    'next_page': string;
    /**
     * The total number of server-signers for the project.
     * @type {number}
     * @memberof ServerSignerList
     */
    'total_count': number;
}
/**
 * An event representing a signature creation.
 * @export
 * @interface SignatureCreationEvent
 */
export interface SignatureCreationEvent {
    /**
     * The ID of the seed that the server-signer should create the signature for
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'seed_id': string;
    /**
     * The ID of the wallet the signature is for
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'wallet_user_id': string;
    /**
     * The ID of the address the transfer belongs to
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'address_id': string;
    /**
     * The index of the address that the server-signer should sign with
     * @type {number}
     * @memberof SignatureCreationEvent
     */
    'address_index': number;
    /**
     * The payload that the server-signer should sign
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'signing_payload': string;
    /**
     *
     * @type {TransactionType}
     * @memberof SignatureCreationEvent
     */
    'transaction_type': TransactionType;
    /**
     * The ID of the transaction that the server-signer should sign
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'transaction_id': string;
}


/**
 * The result to a SignatureCreationEvent.
 * @export
 * @interface SignatureCreationEventResult
 */
export interface SignatureCreationEventResult {
    /**
     * The ID of the wallet that the event was created for.
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'wallet_user_id': string;
    /**
     * The ID of the address the transfer belongs to
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'address_id': string;
    /**
     *
     * @type {TransactionType}
     * @memberof SignatureCreationEventResult
     */
    'transaction_type': TransactionType;
    /**
     * The ID of the transaction that the Server-Signer has signed for
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'transaction_id': string;
    /**
     * The signature created by the server-signer.
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'signature': string;
}


/**
 * Signed voluntary exit message metadata to be provided to beacon chain to exit a validator.
 * @export
 * @interface SignedVoluntaryExitMessageMetadata
 */
export interface SignedVoluntaryExitMessageMetadata {
    /**
     * The public key of the validator associated with the exit message.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'validator_pub_key': string;
    /**
     * The current fork version of the Ethereum beacon chain.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'fork': string;
    /**
     * A base64 encoded version of a json string representing a voluntary exit message.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'signed_voluntary_exit': string;
}
/**
 * Context needed to perform a staking operation
 * @export
 * @interface StakingContext
 */
export interface StakingContext {
    /**
     *
     * @type {StakingContextContext}
     * @memberof StakingContext
     */
    'context': StakingContextContext;
}
/**
 * @type StakingContextContext
 * @export
 */
export type StakingContextContext = NativeEthStakingContext | PartialEthStakingContext;

/**
 * A list of onchain transactions to help realize a staking action.
 * @export
 * @interface StakingOperation
 */
export interface StakingOperation {
    /**
     * The unique ID of the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'id': string;
    /**
     * The ID of the wallet that owns the address.
     * @type {string}
     * @memberof StakingOperation
     */
    'wallet_id'?: string;
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof StakingOperation
     */
    'network_id': string;
    /**
     * The onchain address orchestrating the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'address_id': string;
    /**
     * The status of the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'status': StakingOperationStatusEnum;
    /**
     * The transaction(s) that will execute the staking operation onchain.
     * @type {Array<Transaction>}
     * @memberof StakingOperation
     */
    'transactions': Array<Transaction>;
    /**
     *
     * @type {StakingOperationMetadata}
     * @memberof StakingOperation
     */
    'metadata'?: StakingOperationMetadata;
}

export const StakingOperationStatusEnum = {
    Initialized: 'initialized',
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed',
    Unspecified: 'unspecified'
} as const;

export type StakingOperationStatusEnum = typeof StakingOperationStatusEnum[keyof typeof StakingOperationStatusEnum];

/**
 * @type StakingOperationMetadata
 * @export
 */
export type StakingOperationMetadata = Array<SignedVoluntaryExitMessageMetadata>;

/**
 * The staking rewards for an address.
 * @export
 * @interface StakingReward
 */
export interface StakingReward {
    /**
     * The onchain address for which the staking rewards are being fetched.
     * @type {string}
     * @memberof StakingReward
     */
    'address_id': string;
    /**
     * The date of the reward in format \'YYYY-MM-DD\' in UTC.
     * @type {string}
     * @memberof StakingReward
     */
    'date': string;
    /**
     * The reward amount in requested \"format\". Default is USD.
     * @type {string}
     * @memberof StakingReward
     */
    'amount': string;
    /**
     * The state of the reward.
     * @type {string}
     * @memberof StakingReward
     */
    'state': StakingRewardStateEnum;
    /**
     *
     * @type {StakingRewardFormat}
     * @memberof StakingReward
     */
    'format': StakingRewardFormat;
    /**
     *
     * @type {StakingRewardUSDValue}
     * @memberof StakingReward
     */
    'usd_value': StakingRewardUSDValue;
}

export const StakingRewardStateEnum = {
    Pending: 'pending',
    Distributed: 'distributed'
} as const;

export type StakingRewardStateEnum = typeof StakingRewardStateEnum[keyof typeof StakingRewardStateEnum];

/**
 * The format in which the rewards are to be fetched i.e native or in equivalent USD
 * @export
 * @enum {string}
 */

export const StakingRewardFormat = {
    Usd: 'usd',
    Native: 'native'
} as const;

export type StakingRewardFormat = typeof StakingRewardFormat[keyof typeof StakingRewardFormat];


/**
 * The USD value of the reward
 * @export
 * @interface StakingRewardUSDValue
 */
export interface StakingRewardUSDValue {
    /**
     * The value of the reward in USD
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'amount': string;
    /**
     * The conversion price from native currency to USD
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'conversion_price': string;
    /**
     * The time of the conversion in UTC.
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'conversion_time': string;
}
/**
 * A trade of an asset to another asset
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Trade
     */
    'network_id': string;
    /**
     * The ID of the wallet that owns the from address
     * @type {string}
     * @memberof Trade
     */
    'wallet_id': string;
    /**
     * The onchain address of the sender
     * @type {string}
     * @memberof Trade
     */
    'address_id': string;
    /**
     * The ID of the trade
     * @type {string}
     * @memberof Trade
     */
    'trade_id': string;
    /**
     * The amount of the from asset to be traded (in atomic units of the from asset)
     * @type {string}
     * @memberof Trade
     */
    'from_amount': string;
    /**
     *
     * @type {Asset}
     * @memberof Trade
     */
    'from_asset': Asset;
    /**
     * The amount of the to asset that will be received (in atomic units of the to asset)
     * @type {string}
     * @memberof Trade
     */
    'to_amount': string;
    /**
     *
     * @type {Asset}
     * @memberof Trade
     */
    'to_asset': Asset;
    /**
     *
     * @type {Transaction}
     * @memberof Trade
     */
    'transaction': Transaction;
    /**
     *
     * @type {Transaction}
     * @memberof Trade
     */
    'approve_transaction'?: Transaction;
}
/**
 *
 * @export
 * @interface TradeList
 */
export interface TradeList {
    /**
     *
     * @type {Array<Trade>}
     * @memberof TradeList
     */
    'data': Array<Trade>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof TradeList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof TradeList
     */
    'next_page': string;
    /**
     * The total number of trades for the address in the wallet.
     * @type {number}
     * @memberof TradeList
     */
    'total_count': number;
}
/**
 * An onchain transaction.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Transaction
     */
    'network_id': string;
    /**
     * The onchain address of the sender
     * @type {string}
     * @memberof Transaction
     */
    'from_address_id': string;
    /**
     * The unsigned payload of the transaction. This is the payload that needs to be signed by the sender.
     * @type {string}
     * @memberof Transaction
     */
    'unsigned_payload': string;
    /**
     * The signed payload of the transaction. This is the payload that has been signed by the sender.
     * @type {string}
     * @memberof Transaction
     */
    'signed_payload'?: string;
    /**
     * The hash of the transaction
     * @type {string}
     * @memberof Transaction
     */
    'transaction_hash'?: string;
    /**
     * The link to view the transaction on a block explorer. This is optional and may not be present for all transactions.
     * @type {string}
     * @memberof Transaction
     */
    'transaction_link'?: string;
    /**
     * The status of the transaction
     * @type {string}
     * @memberof Transaction
     */
    'status': TransactionStatusEnum;
}

export const TransactionStatusEnum = {
    Pending: 'pending',
    Signed: 'signed',
    Broadcast: 'broadcast',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Transfer: 'transfer'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * A transfer of an asset from one address to another
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Transfer
     */
    'network_id': string;
    /**
     * The ID of the wallet that owns the from address
     * @type {string}
     * @memberof Transfer
     */
    'wallet_id': string;
    /**
     * The onchain address of the sender
     * @type {string}
     * @memberof Transfer
     */
    'address_id': string;
    /**
     * The onchain address of the recipient
     * @type {string}
     * @memberof Transfer
     */
    'destination': string;
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof Transfer
     */
    'amount': string;
    /**
     * The ID of the asset being transferred
     * @type {string}
     * @memberof Transfer
     */
    'asset_id': string;
    /**
     *
     * @type {Asset}
     * @memberof Transfer
     */
    'asset': Asset;
    /**
     * The ID of the transfer
     * @type {string}
     * @memberof Transfer
     */
    'transfer_id': string;
    /**
     *
     * @type {Transaction}
     * @memberof Transfer
     */
    'transaction': Transaction;
    /**
     * The unsigned payload of the transfer. This is the payload that needs to be signed by the sender.
     * @type {string}
     * @memberof Transfer
     */
    'unsigned_payload'?: string;
    /**
     * The signed payload of the transfer. This is the payload that has been signed by the sender.
     * @type {string}
     * @memberof Transfer
     */
    'signed_payload'?: string;
    /**
     * The hash of the transfer transaction
     * @type {string}
     * @memberof Transfer
     */
    'transaction_hash'?: string;
    /**
     * The status of the transfer
     * @type {string}
     * @memberof Transfer
     */
    'status'?: TransferStatusEnum;
}

export const TransferStatusEnum = {
    Pending: 'pending',
    Broadcast: 'broadcast',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type TransferStatusEnum = typeof TransferStatusEnum[keyof typeof TransferStatusEnum];

/**
 *
 * @export
 * @interface TransferList
 */
export interface TransferList {
    /**
     *
     * @type {Array<Transfer>}
     * @memberof TransferList
     */
    'data': Array<Transfer>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof TransferList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof TransferList
     */
    'next_page': string;
    /**
     * The total number of transfers for the address in the wallet.
     * @type {number}
     * @memberof TransferList
     */
    'total_count': number;
}
/**
 *
 * @export
 * @interface UpdateWebhookRequest
 */
export interface UpdateWebhookRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'network_id'?: string;
    /**
     *
     * @type {WebhookEventType}
     * @memberof UpdateWebhookRequest
     */
    'event_type': WebhookEventType;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof UpdateWebhookRequest
     */
    'event_filters': Array<WebhookEventFilter>;
    /**
     * The Webhook uri that updates to
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'notification_uri': string;
}


/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     * The ID of the user
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'display_name'?: string;
}
/**
 * A validator onchain.
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * The publicly identifiable unique id of the validator. This can be the public key for Ethereum validators and maybe an address for some other network.
     * @type {string}
     * @memberof Validator
     */
    'validator_id': string;
    /**
     * The ID of the blockchain network to which the Validator belongs.
     * @type {string}
     * @memberof Validator
     */
    'network_id': string;
    /**
     * The ID of the asset that the validator helps stake.
     * @type {string}
     * @memberof Validator
     */
    'asset_id': string;
    /**
     * The status of the validator.
     * @type {string}
     * @memberof Validator
     */
    'status': string;
    /**
     *
     * @type {ValidatorDetails}
     * @memberof Validator
     */
    'details'?: ValidatorDetails;
}
/**
 * @type ValidatorDetails
 * @export
 */
export type ValidatorDetails = EthereumValidatorMetadata;

/**
 *
 * @export
 * @interface ValidatorList
 */
export interface ValidatorList {
    /**
     *
     * @type {Array<Validator>}
     * @memberof ValidatorList
     */
    'data': Array<Validator>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ValidatorList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ValidatorList
     */
    'next_page': string;
}
/**
 *
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * The server-assigned ID for the wallet.
     * @type {string}
     * @memberof Wallet
     */
    'id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Wallet
     */
    'network_id': string;
    /**
     *
     * @type {Address}
     * @memberof Wallet
     */
    'default_address'?: Address;
    /**
     * The features enabled for the wallet
     * @type {Array<Feature>}
     * @memberof Wallet
     */
    'enabled_features': Array<Feature>;
    /**
     * The status of the Server-Signer for the wallet if present.
     * @type {string}
     * @memberof Wallet
     */
    'server_signer_status'?: WalletServerSignerStatusEnum;
}

export const WalletServerSignerStatusEnum = {
    PendingSeedCreation: 'pending_seed_creation',
    ActiveSeed: 'active_seed'
} as const;

export type WalletServerSignerStatusEnum = typeof WalletServerSignerStatusEnum[keyof typeof WalletServerSignerStatusEnum];

/**
 * Paginated list of wallets
 * @export
 * @interface WalletList
 */
export interface WalletList {
    /**
     *
     * @type {Array<Wallet>}
     * @memberof WalletList
     */
    'data': Array<Wallet>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof WalletList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof WalletList
     */
    'next_page': string;
    /**
     * The total number of wallets
     * @type {number}
     * @memberof WalletList
     */
    'total_count': number;
}
/**
 * Webhook that is used for getting notifications when monitored events occur.
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Identifier of the webhook.
     * @type {string}
     * @memberof Webhook
     */
    'id'?: string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Webhook
     */
    'network_id'?: string;
    /**
     *
     * @type {WebhookEventType}
     * @memberof Webhook
     */
    'event_type'?: WebhookEventType;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof Webhook
     */
    'event_filters'?: Array<WebhookEventFilter>;
    /**
     * The URL to which the notifications will be sent.
     * @type {string}
     * @memberof Webhook
     */
    'notification_uri'?: string;
    /**
     * The date and time the webhook was created.
     * @type {string}
     * @memberof Webhook
     */
    'created_at'?: string;
    /**
     * The date and time the webhook was last updated.
     * @type {string}
     * @memberof Webhook
     */
    'updated_at'?: string;
}


/**
 * The event_filter parameter specifies the criteria to filter events from the blockchain. It allows filtering events by contract address, sender address and receiver address. For a single event filter, not all of the properties need to be presented.
 * @export
 * @interface WebhookEventFilter
 */
export interface WebhookEventFilter {
    /**
     * The onchain contract address of the token being transferred.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'contract_address'?: string;
    /**
     * The onchain address of the sender.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'from_address'?: string;
    /**
     * The onchain address of the receiver.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'to_address'?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const WebhookEventType = {
    Unspecified: 'unspecified',
    Erc20Transfer: 'erc20_transfer',
    Erc721Transfer: 'erc721_transfer'
} as const;

export type WebhookEventType = typeof WebhookEventType[keyof typeof WebhookEventType];


/**
 *
 * @export
 * @interface WebhookList
 */
export interface WebhookList {
    /**
     *
     * @type {Array<Webhook>}
     * @memberof WebhookList
     */
    'data': Array<Webhook>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof WebhookList
     */
    'has_more'?: boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof WebhookList
     */
    'next_page'?: string;
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress: async (walletId: string, createAddressRequest?: CreateAddressRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createAddress', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress: async (walletId: string, addressId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getAddress', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getAddress', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressBalance: async (walletId: string, addressId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getAddressBalance', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getAddressBalance', 'addressId', addressId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAddressBalance', 'assetId', assetId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances/{asset_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressBalances: async (walletId: string, addressId: string, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listAddressBalances', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listAddressBalances', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses: async (walletId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listAddresses', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestFaucetFunds: async (walletId: string, addressId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('requestFaucetFunds', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('requestFaucetFunds', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/faucet`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(walletId, createAddressRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.createAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(walletId, addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.getAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressBalance(walletId, addressId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.getAddressBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressBalances(walletId, addressId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.listAddressBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(walletId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.listAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestFaucetFunds(walletId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFaucetFunds(walletId, addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.requestFaucetFunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: any): AxiosPromise<Address> {
            return localVarFp.createAddress(walletId, createAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress(walletId: string, addressId: string, options?: any): AxiosPromise<Address> {
            return localVarFp.getAddress(walletId, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressBalance(walletId: string, addressId: string, assetId: string, options?: any): AxiosPromise<Balance> {
            return localVarFp.getAddressBalance(walletId, addressId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressBalances(walletId: string, addressId: string, page?: string, options?: any): AxiosPromise<AddressBalanceList> {
            return localVarFp.listAddressBalances(walletId, addressId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses(walletId: string, limit?: number, page?: string, options?: any): AxiosPromise<AddressList> {
            return localVarFp.listAddresses(walletId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestFaucetFunds(walletId: string, addressId: string, options?: any): AxiosPromise<FaucetTransaction> {
            return localVarFp.requestFaucetFunds(walletId, addressId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - interface
 * @export
 * @interface AddressesApi
 */
export interface AddressesApiInterface {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<Address>;

    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<Address>;

    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;

    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;

    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressList>;

    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    requestFaucetFunds(walletId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;

}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI implements AddressesApiInterface {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).createAddress(walletId, createAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).getAddress(walletId, addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).getAddressBalance(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).listAddressBalances(walletId, addressId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).listAddresses(walletId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public requestFaucetFunds(walletId: string, addressId: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).requestFaucetFunds(walletId, addressId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (networkId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getAsset', 'networkId', networkId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAsset', 'assetId', assetId)
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(networkId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.getAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(networkId: string, assetId: string, options?: any): AxiosPromise<Asset> {
            return localVarFp.getAsset(networkId, assetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - interface
 * @export
 * @interface AssetsApi
 */
export interface AssetsApiInterface {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApiInterface
     */
    getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Asset>;

}

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI implements AssetsApiInterface {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).getAsset(networkId, assetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContractEventsApi - axios parameter creator
 * @export
 */
export const ContractEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve events for a specific contract
         * @summary Get contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [contractName] Case-sensitive name of the specific contract within the project
         * @param {string} [eventName] Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractEvents: async (networkId: string, protocolName: string, contractAddress: string, fromBlockHeight: number, toBlockHeight: number, contractName?: string, eventName?: string, nextPage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listContractEvents', 'networkId', networkId)
            // verify required parameter 'protocolName' is not null or undefined
            assertParamExists('listContractEvents', 'protocolName', protocolName)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('listContractEvents', 'contractAddress', contractAddress)
            // verify required parameter 'fromBlockHeight' is not null or undefined
            assertParamExists('listContractEvents', 'fromBlockHeight', fromBlockHeight)
            // verify required parameter 'toBlockHeight' is not null or undefined
            assertParamExists('listContractEvents', 'toBlockHeight', toBlockHeight)
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/events`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (protocolName !== undefined) {
                localVarQueryParameter['protocol_name'] = protocolName;
            }

            if (contractName !== undefined) {
                localVarQueryParameter['contract_name'] = contractName;
            }

            if (eventName !== undefined) {
                localVarQueryParameter['event_name'] = eventName;
            }

            if (fromBlockHeight !== undefined) {
                localVarQueryParameter['from_block_height'] = fromBlockHeight;
            }

            if (toBlockHeight !== undefined) {
                localVarQueryParameter['to_block_height'] = toBlockHeight;
            }

            if (nextPage !== undefined) {
                localVarQueryParameter['next_page'] = nextPage;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractEventsApi - functional programming interface
 * @export
 */
export const ContractEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve events for a specific contract
         * @summary Get contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [contractName] Case-sensitive name of the specific contract within the project
         * @param {string} [eventName] Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContractEvents(networkId: string, protocolName: string, contractAddress: string, fromBlockHeight: number, toBlockHeight: number, contractName?: string, eventName?: string, nextPage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractEvents(networkId, protocolName, contractAddress, fromBlockHeight, toBlockHeight, contractName, eventName, nextPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractEventsApi.listContractEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContractEventsApi - factory interface
 * @export
 */
export const ContractEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractEventsApiFp(configuration)
    return {
        /**
         * Retrieve events for a specific contract
         * @summary Get contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [contractName] Case-sensitive name of the specific contract within the project
         * @param {string} [eventName] Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractEvents(networkId: string, protocolName: string, contractAddress: string, fromBlockHeight: number, toBlockHeight: number, contractName?: string, eventName?: string, nextPage?: string, options?: any): AxiosPromise<ContractEventList> {
            return localVarFp.listContractEvents(networkId, protocolName, contractAddress, fromBlockHeight, toBlockHeight, contractName, eventName, nextPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractEventsApi - interface
 * @export
 * @interface ContractEventsApi
 */
export interface ContractEventsApiInterface {
    /**
     * Retrieve events for a specific contract
     * @summary Get contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [contractName] Case-sensitive name of the specific contract within the project
     * @param {string} [eventName] Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractEventsApiInterface
     */
    listContractEvents(networkId: string, protocolName: string, contractAddress: string, fromBlockHeight: number, toBlockHeight: number, contractName?: string, eventName?: string, nextPage?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractEventList>;

}

/**
 * ContractEventsApi - object-oriented interface
 * @export
 * @class ContractEventsApi
 * @extends {BaseAPI}
 */
export class ContractEventsApi extends BaseAPI implements ContractEventsApiInterface {
    /**
     * Retrieve events for a specific contract
     * @summary Get contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [contractName] Case-sensitive name of the specific contract within the project
     * @param {string} [eventName] Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractEventsApi
     */
    public listContractEvents(networkId: string, protocolName: string, contractAddress: string, fromBlockHeight: number, toBlockHeight: number, contractName?: string, eventName?: string, nextPage?: string, options?: RawAxiosRequestConfig) {
        return ContractEventsApiFp(this.configuration).listContractEvents(networkId, protocolName, contractAddress, fromBlockHeight, toBlockHeight, contractName, eventName, nextPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExternalAddressesApi - axios parameter creator
 * @export
 */
export const ExternalAddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalAddressBalance: async (networkId: string, addressId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getExternalAddressBalance', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getExternalAddressBalance', 'addressId', addressId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getExternalAddressBalance', 'assetId', assetId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressHistoricalBalance: async (networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listAddressHistoricalBalance', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listAddressHistoricalBalance', 'addressId', addressId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('listAddressHistoricalBalance', 'assetId', assetId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balance_history/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExternalAddressBalances: async (networkId: string, addressId: string, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listExternalAddressBalances', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listExternalAddressBalances', 'addressId', addressId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestExternalFaucetFunds: async (networkId: string, addressId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('requestExternalFaucetFunds', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('requestExternalFaucetFunds', 'addressId', addressId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalAddressesApi - functional programming interface
 * @export
 */
export const ExternalAddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalAddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalAddressBalance(networkId, addressId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.getExternalAddressBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressHistoricalBalanceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.listAddressHistoricalBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExternalAddressBalances(networkId, addressId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.listExternalAddressBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestExternalFaucetFunds(networkId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestExternalFaucetFunds(networkId, addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAddressesApi.requestExternalFaucetFunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExternalAddressesApi - factory interface
 * @export
 */
export const ExternalAddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalAddressesApiFp(configuration)
    return {
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: any): AxiosPromise<Balance> {
            return localVarFp.getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: any): AxiosPromise<AddressHistoricalBalanceList> {
            return localVarFp.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: any): AxiosPromise<AddressBalanceList> {
            return localVarFp.listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestExternalFaucetFunds(networkId: string, addressId: string, options?: any): AxiosPromise<FaucetTransaction> {
            return localVarFp.requestExternalFaucetFunds(networkId, addressId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalAddressesApi - interface
 * @export
 * @interface ExternalAddressesApi
 */
export interface ExternalAddressesApiInterface {
    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;

    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressHistoricalBalanceList>;

    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;

    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    requestExternalFaucetFunds(networkId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;

}

/**
 * ExternalAddressesApi - object-oriented interface
 * @export
 * @class ExternalAddressesApi
 * @extends {BaseAPI}
 */
export class ExternalAddressesApi extends BaseAPI implements ExternalAddressesApiInterface {
    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    public requestExternalFaucetFunds(networkId: string, addressId: string, options?: RawAxiosRequestConfig) {
        return ExternalAddressesApiFp(this.configuration).requestExternalFaucetFunds(networkId, addressId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerSignersApi - axios parameter creator
 * @export
 */
export const ServerSignersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServerSigner: async (createServerSignerRequest?: CreateServerSignerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/server_signers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServerSignerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSigner: async (serverSignerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverSignerId' is not null or undefined
            assertParamExists('getServerSigner', 'serverSignerId', serverSignerId)
            const localVarPath = `/v1/server_signers/{server_signer_id}`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerSignerEvents: async (serverSignerId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverSignerId' is not null or undefined
            assertParamExists('listServerSignerEvents', 'serverSignerId', serverSignerId)
            const localVarPath = `/v1/server_signers/{server_signer_id}/events`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerSigners: async (limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/server_signers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSeedEventResult: async (serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverSignerId' is not null or undefined
            assertParamExists('submitServerSignerSeedEventResult', 'serverSignerId', serverSignerId)
            const localVarPath = `/v1/server_signers/{server_signer_id}/seed_event_result`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(seedCreationEventResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSignatureEventResult: async (serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverSignerId' is not null or undefined
            assertParamExists('submitServerSignerSignatureEventResult', 'serverSignerId', serverSignerId)
            const localVarPath = `/v1/server_signers/{server_signer_id}/signature_event_result`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signatureCreationEventResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerSignersApi - functional programming interface
 * @export
 */
export const ServerSignersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerSignersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSigner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServerSigner(createServerSignerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.createServerSigner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSigner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSigner(serverSignerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.getServerSigner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSignerEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSignerEvents(serverSignerId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.listServerSignerEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSignerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSigners(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.listServerSigners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeedCreationEventResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.submitServerSignerSeedEventResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureCreationEventResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSignersApi.submitServerSignerSignatureEventResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerSignersApi - factory interface
 * @export
 */
export const ServerSignersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerSignersApiFp(configuration)
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: any): AxiosPromise<ServerSigner> {
            return localVarFp.createServerSigner(createServerSignerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSigner(serverSignerId: string, options?: any): AxiosPromise<ServerSigner> {
            return localVarFp.getServerSigner(serverSignerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: any): AxiosPromise<ServerSignerEventList> {
            return localVarFp.listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerSigners(limit?: number, page?: string, options?: any): AxiosPromise<ServerSignerList> {
            return localVarFp.listServerSigners(limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: any): AxiosPromise<SeedCreationEventResult> {
            return localVarFp.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: any): AxiosPromise<SignatureCreationEventResult> {
            return localVarFp.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerSignersApi - interface
 * @export
 * @interface ServerSignersApi
 */
export interface ServerSignersApiInterface {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner>;

    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner>;

    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerEventList>;

    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerList>;

    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SeedCreationEventResult>;

    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCreationEventResult>;

}

/**
 * ServerSignersApi - object-oriented interface
 * @export
 * @class ServerSignersApi
 * @extends {BaseAPI}
 */
export class ServerSignersApi extends BaseAPI implements ServerSignersApiInterface {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).createServerSigner(createServerSignerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).getServerSigner(serverSignerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).listServerSigners(limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    public submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig) {
        return ServerSignersApiFp(this.configuration).submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StakeApi - axios parameter creator
 * @export
 */
export const StakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastStakingOperation: async (walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('broadcastStakingOperation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('broadcastStakingOperation', 'addressId', addressId)
            // verify required parameter 'stakingOperationId' is not null or undefined
            assertParamExists('broadcastStakingOperation', 'stakingOperationId', stakingOperationId)
            // verify required parameter 'broadcastStakingOperationRequest' is not null or undefined
            assertParamExists('broadcastStakingOperation', 'broadcastStakingOperationRequest', broadcastStakingOperationRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastStakingOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildStakingOperation: async (buildStakingOperationRequest: BuildStakingOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'buildStakingOperationRequest' is not null or undefined
            assertParamExists('buildStakingOperation', 'buildStakingOperationRequest', buildStakingOperationRequest)
            const localVarPath = `/v1/stake/build`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildStakingOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStakingOperation: async (walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createStakingOperation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createStakingOperation', 'addressId', addressId)
            // verify required parameter 'createStakingOperationRequest' is not null or undefined
            assertParamExists('createStakingOperation', 'createStakingOperationRequest', createStakingOperationRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStakingOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStakingRewards: async (fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fetchStakingRewardsRequest' is not null or undefined
            assertParamExists('fetchStakingRewards', 'fetchStakingRewardsRequest', fetchStakingRewardsRequest)
            const localVarPath = `/v1/stake/rewards/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fetchStakingRewardsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalStakingOperation: async (networkId: string, addressId: string, stakingOperationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getExternalStakingOperation', 'networkId', networkId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getExternalStakingOperation', 'addressId', addressId)
            // verify required parameter 'stakingOperationId' is not null or undefined
            assertParamExists('getExternalStakingOperation', 'stakingOperationId', stakingOperationId)
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingContext: async (getStakingContextRequest: GetStakingContextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getStakingContextRequest' is not null or undefined
            assertParamExists('getStakingContext', 'getStakingContextRequest', getStakingContextRequest)
            const localVarPath = `/v1/stake/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStakingContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingOperation: async (walletId: string, addressId: string, stakingOperationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getStakingOperation', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getStakingOperation', 'addressId', addressId)
            // verify required parameter 'stakingOperationId' is not null or undefined
            assertParamExists('getStakingOperation', 'stakingOperationId', stakingOperationId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StakeApi - functional programming interface
 * @export
 */
export const StakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StakeApiAxiosParamCreator(configuration)
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.broadcastStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildStakingOperation(buildStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.buildStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStakingOperation(walletId, addressId, createStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.createStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchStakingRewards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.fetchStakingRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalStakingOperation(networkId, addressId, stakingOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.getExternalStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingContext(getStakingContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.getStakingContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingOperation(walletId, addressId, stakingOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakeApi.getStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StakeApi - factory interface
 * @export
 */
export const StakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StakeApiFp(configuration)
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: any): AxiosPromise<StakingOperation> {
            return localVarFp.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: any): AxiosPromise<StakingOperation> {
            return localVarFp.buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: any): AxiosPromise<StakingOperation> {
            return localVarFp.createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: any): AxiosPromise<FetchStakingRewards200Response> {
            return localVarFp.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: any): AxiosPromise<StakingOperation> {
            return localVarFp.getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: any): AxiosPromise<StakingContext> {
            return localVarFp.getStakingContext(getStakingContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: any): AxiosPromise<StakingOperation> {
            return localVarFp.getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StakeApi - interface
 * @export
 * @interface StakeApi
 */
export interface StakeApiInterface {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchStakingRewards200Response>;

    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingContext>;

    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;

}

/**
 * StakeApi - object-oriented interface
 * @export
 * @class StakeApi
 * @extends {BaseAPI}
 */
export class StakeApi extends BaseAPI implements StakeApiInterface {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).getStakingContext(getStakingContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    public getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig) {
        return StakeApiFp(this.configuration).getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TradesApi - axios parameter creator
 * @export
 */
export const TradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTrade: async (walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('broadcastTrade', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('broadcastTrade', 'addressId', addressId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('broadcastTrade', 'tradeId', tradeId)
            // verify required parameter 'broadcastTradeRequest' is not null or undefined
            assertParamExists('broadcastTrade', 'broadcastTradeRequest', broadcastTradeRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade: async (walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createTrade', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createTrade', 'addressId', addressId)
            // verify required parameter 'createTradeRequest' is not null or undefined
            assertParamExists('createTrade', 'createTradeRequest', createTradeRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (walletId: string, addressId: string, tradeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getTrade', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getTrade', 'addressId', addressId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('getTrade', 'tradeId', tradeId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (walletId: string, addressId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listTrades', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listTrades', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradesApi - functional programming interface
 * @export
 */
export const TradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradesApiAxiosParamCreator(configuration)
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradesApi.broadcastTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrade(walletId, addressId, createTradeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradesApi.createTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(walletId, addressId, tradeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradesApi.getTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradesApi.listTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradesApi - factory interface
 * @export
 */
export const TradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradesApiFp(configuration)
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: any): AxiosPromise<Trade> {
            return localVarFp.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: any): AxiosPromise<Trade> {
            return localVarFp.createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(walletId: string, addressId: string, tradeId: string, options?: any): AxiosPromise<Trade> {
            return localVarFp.getTrade(walletId, addressId, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: any): AxiosPromise<TradeList> {
            return localVarFp.listTrades(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradesApi - interface
 * @export
 * @interface TradesApi
 */
export interface TradesApiInterface {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;

    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;

    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;

    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TradeList>;

}

/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
export class TradesApi extends BaseAPI implements TradesApiInterface {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig) {
        return TradesApiFp(this.configuration).broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig) {
        return TradesApiFp(this.configuration).createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig) {
        return TradesApiFp(this.configuration).getTrade(walletId, addressId, tradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return TradesApiFp(this.configuration).listTrades(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTransfer: async (walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('broadcastTransfer', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('broadcastTransfer', 'addressId', addressId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('broadcastTransfer', 'transferId', transferId)
            // verify required parameter 'broadcastTransferRequest' is not null or undefined
            assertParamExists('broadcastTransfer', 'broadcastTransferRequest', broadcastTransferRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createTransfer', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createTransfer', 'addressId', addressId)
            // verify required parameter 'createTransferRequest' is not null or undefined
            assertParamExists('createTransfer', 'createTransferRequest', createTransferRequest)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (walletId: string, addressId: string, transferId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getTransfer', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getTransfer', 'addressId', addressId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('getTransfer', 'transferId', transferId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers: async (walletId: string, addressId: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listTransfers', 'walletId', walletId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('listTransfers', 'addressId', addressId)
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.broadcastTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(walletId, addressId, createTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.createTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(walletId, addressId, transferId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.getTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.listTransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: any): AxiosPromise<Transfer> {
            return localVarFp.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: any): AxiosPromise<Transfer> {
            return localVarFp.createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(walletId: string, addressId: string, transferId: string, options?: any): AxiosPromise<Transfer> {
            return localVarFp.getTransfer(walletId, addressId, transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: any): AxiosPromise<TransferList> {
            return localVarFp.listTransfers(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - interface
 * @export
 * @interface TransfersApi
 */
export interface TransfersApiInterface {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;

    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TransferList>;

}

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI implements TransfersApiInterface {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getTransfer(walletId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).listTransfers(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ValidatorsApi - axios parameter creator
 * @export
 */
export const ValidatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator: async (networkId: string, assetId: string, validatorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getValidator', 'networkId', networkId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getValidator', 'assetId', assetId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('getValidator', 'validatorId', validatorId)
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators/{validator_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {string} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValidators: async (networkId: string, assetId: string, status?: string, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('listValidators', 'networkId', networkId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('listValidators', 'assetId', assetId)
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidatorsApi - functional programming interface
 * @export
 */
export const ValidatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(networkId, assetId, validatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValidatorsApi.getValidator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {string} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listValidators(networkId: string, assetId: string, status?: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listValidators(networkId, assetId, status, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValidatorsApi.listValidators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ValidatorsApi - factory interface
 * @export
 */
export const ValidatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidatorsApiFp(configuration)
    return {
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator(networkId: string, assetId: string, validatorId: string, options?: any): AxiosPromise<Validator> {
            return localVarFp.getValidator(networkId, assetId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {string} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValidators(networkId: string, assetId: string, status?: string, limit?: number, page?: string, options?: any): AxiosPromise<ValidatorList> {
            return localVarFp.listValidators(networkId, assetId, status, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidatorsApi - interface
 * @export
 * @interface ValidatorsApi
 */
export interface ValidatorsApiInterface {
    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApiInterface
     */
    getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Validator>;

    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {string} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApiInterface
     */
    listValidators(networkId: string, assetId: string, status?: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ValidatorList>;

}

/**
 * ValidatorsApi - object-oriented interface
 * @export
 * @class ValidatorsApi
 * @extends {BaseAPI}
 */
export class ValidatorsApi extends BaseAPI implements ValidatorsApiInterface {
    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig) {
        return ValidatorsApiFp(this.configuration).getValidator(networkId, assetId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {string} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public listValidators(networkId: string, assetId: string, status?: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return ValidatorsApiFp(this.configuration).listValidators(networkId, assetId, status, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletsApi - axios parameter creator
 * @export
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet: async (createWalletRequest?: CreateWalletRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet: async (walletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getWallet', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance: async (walletId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getWalletBalance', 'walletId', walletId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getWalletBalance', 'assetId', assetId)
            const localVarPath = `/v1/wallets/{wallet_id}/balances/{asset_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWalletBalances: async (walletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listWalletBalances', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{wallet_id}/balances`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets: async (limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletsApi - functional programming interface
 * @export
 */
export const WalletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(createWalletRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.createWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallet(walletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(walletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.getWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(walletId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletBalances(walletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.listWalletBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.listWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletsApi - factory interface
 * @export
 */
export const WalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletsApiFp(configuration)
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet(createWalletRequest?: CreateWalletRequest, options?: any): AxiosPromise<Wallet> {
            return localVarFp.createWallet(createWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(walletId: string, options?: any): AxiosPromise<Wallet> {
            return localVarFp.getWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance(walletId: string, assetId: string, options?: any): AxiosPromise<Balance> {
            return localVarFp.getWalletBalance(walletId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWalletBalances(walletId: string, options?: any): AxiosPromise<AddressBalanceList> {
            return localVarFp.listWalletBalances(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets(limit?: number, page?: string, options?: any): AxiosPromise<WalletList> {
            return localVarFp.listWallets(limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletsApi - interface
 * @export
 * @interface WalletsApi
 */
export interface WalletsApiInterface {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<Wallet>;

    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    getWallet(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<Wallet>;

    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;

    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;

    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletList>;

}

/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI implements WalletsApiInterface {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).createWallet(createWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public getWallet(walletId: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).getWalletBalance(walletId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public listWalletBalances(walletId: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).listWalletBalances(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).listWallets(limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookRequest?: CreateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            const localVarPath = `/v1/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: any): AxiosPromise<Webhook> {
            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(limit?: number, page?: string, options?: any): AxiosPromise<WebhookList> {
            return localVarFp.listWebhooks(limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: any): AxiosPromise<Webhook> {
            return localVarFp.updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - interface
 * @export
 * @interface WebhooksApi
 */
export interface WebhooksApiInterface {
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;

    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookList>;

    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;

}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI implements WebhooksApiInterface {
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).listWebhooks(limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



